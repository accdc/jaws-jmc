<?xml version="1.0"?>
<component>

<registration
description="HomerJax script component"
progid="Homer.Jax"
version="1.00"
classid="{84ab845e-9bd2-464a-828e-801651c7c77b}"
>
</registration>

<public>
<method name="DialogConfirm">
<PARAMETER name="sTitle"/>
<PARAMETER name="sMessage"/>
<PARAMETER name="sDefault"/>
</method>

<method name="DialogInput">
<PARAMETER name="sTitle"/>
<PARAMETER name="sField"/>
<PARAMETER name="sValue"/>
</method>

<method name="DialogShow">
<PARAMETER name="oTitle"/>
<PARAMETER name="oText"/>
</method>

<method name="FileIsUnicode">
<PARAMETER name="sFile"/>
</method>

<method name="FileIsUTF8">
<PARAMETER name="sFile"/>
</method>

<method name="ProcessGetModules">
</method>

<method name="ProcessIsModuleActive">
<PARAMETER name="sName"/>
</method>

<method name="ProcessQueryName">
<PARAMETER name="sName"/>
</method>

<method name="ProcessTerminateModule">
<PARAMETER name="sName"/>
</method>

<method name="RegistryGetString">
<PARAMETER name="iRootKey"/>
<PARAMETER name="sSubKey"/>
<PARAMETER name="sValueName"/>
</method>

<method name="RegistryRead">
<PARAMETER name="sKey"/>
</method>

<method name="RegistrySetString">
<PARAMETER name="iRootKey"/>
<PARAMETER name="sSubKey"/>
<PARAMETER name="sValueName"/>
<PARAMETER name="sValueData"/>
</method>

<method name="RegistryWrite">
<PARAMETER name="sKey"/>
<PARAMETER name="sValue"/>
</method>

<method name="StringIsUnicode">
<PARAMETER name="sText"/>
</method>

<method name="StringIsUTF8">
<PARAMETER name="sText"/>
</method>

<method name="StringPrependUTF8">
<PARAMETER name="sText"/>
</method>

<method name="StringReplace">
<PARAMETER name="sText"/>
<PARAMETER name="sMatch"/>
<PARAMETER name="sReplace"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="VBSEval">
<PARAMETER name="sCode"/>
<PARAMETER name="v1"/>
<PARAMETER name="v2"/>
<PARAMETER name="v3"/>
<PARAMETER name="v4"/>
</method>

<method name="VtSleep">
<PARAMETER name="iMilliseconds"/>
</method>

<method name="VtStr">
<PARAMETER name="sText"/>
</method>

<method name="VtTrim">
<PARAMETER name="sText"/>
</method>

<method name="VtTypeName">
<PARAMETER name="vVariant"/>
</method>

<method name="FileCopy">
<PARAMETER name="sSource"/>
<PARAMETER name="sTarget"/>
</method>

<method name="FileDelete">
<PARAMETER name="sFile"/>
</method>

<method name="FileExists">
<PARAMETER name="sFile"/>
</method>

<method name="FileGetDate">
<PARAMETER name="sFile"/>
</method>

<method name="FileGetSize">
<PARAMETER name="sFile"/>
</method>

<method name="FileGetType">
<PARAMETER name="sFile"/>
</method>

<method name="FileMove">
<PARAMETER name="sSource"/>
<PARAMETER name="sTarget"/>
</method>

<method name="FileToString">
<PARAMETER name="sFile"/>
</method>

<method name="FolderCopy">
<PARAMETER name="sSource"/>
<PARAMETER name="sTarget"/>
</method>

<method name="FolderCreate">
<PARAMETER name="sFolder"/>
</method>

<method name="FolderDelete">
<PARAMETER name="sFolder"/>
</method>

<method name="FolderExists">
<PARAMETER name="sFolder"/>
</method>

<method name="FolderGetDate">
<PARAMETER name="sFolder"/>
</method>

<method name="FolderGetSize">
<PARAMETER name="sFolder"/>
</method>

<method name="FolderMove">
<PARAMETER name="sSource"/>
<PARAMETER name="sTarget"/>
</method>

<method name="HtmlDecodeString">
<PARAMETER name="sText"/>
</method>

<method name="HtmlEncodeString">
<PARAMETER name="sText"/>
</method>

<method name="HtmlGetLinks">
<PARAMETER name="sUrl"/>
<PARAMETER name="bIncludeDownloadName"/>
</method>

<method name="HtmlGetLinkTextAndUrls">
<PARAMETER name="sUrl"/>
</method>

<method name="HtmlGetTableText">
<PARAMETER name="sUrl"/>
<PARAMETER name="iTable"/>
</method>

<method name="HtmlGetText">
<PARAMETER name="sUrl"/>
<PARAMETER name="bAddHeader"/>
</method>

<method name="HtmlGetUrls">
<PARAMETER name="sUrl"/>
</method>
<method name="JsDictionaryToEncodedString">
<PARAMETER name="d"/>
</method>

<method name="JsDictionaryToVt">
<PARAMETER name="d"/>
</method>

<method name="JsEval">
<PARAMETER name="sCode"/>
<PARAMETER name="o1"/>
<PARAMETER name="o2"/>
<PARAMETER name="o3"/>
<PARAMETER name="o4"/>
</method>

<method name="JsInitArray">
<PARAMETER name="oValue"/>
<PARAMETER name="iLength"/>
</method>

<method name="JsInspectObject">
<PARAMETER name="sName"/>
<PARAMETER name="oValue"/>
</method>

<method name="JsIsBlank">
<PARAMETER name="sText"/>
</method>

<method name="JsIsMute">
<PARAMETER name="o"/>
</method>

<method name="JsIsNull">
<PARAMETER name="o"/>
</method>

<method name="JsIsObject">
<PARAMETER name="o"/>
</method>

<method name="JsIsUndefined">
<PARAMETER name="o"/>
</method>

<method name="JsMin">
<PARAMETER name="i"/>
<PARAMETER name="j"/>
</method>

<method name="JSNumber">
<PARAMETER name="o"/>
</method>

<method name="JsObjectToVt">
<PARAMETER name="oValue"/>
</method>

<method name="JsPrint">
<PARAMETER name="o"/>
</method>

<method name="JsPrintObject">
<PARAMETER name="sName"/>
<PARAMETER name="oValue"/>
</method>

<method name="JsSplit">
<PARAMETER name="sText"/>
<PARAMETER name="sDelimiter"/>
</method>

<method name="JsSplitLines">
<PARAMETER name="sText"/>
</method>

<method name="JsString">
<PARAMETER name="o"/>
</method>

<method name="JsToVt">
<PARAMETER name="sJs"/>
</method>

<method name="PathCombine">
<PARAMETER name="sFolder"/>
<PARAMETER name="sName"/>
</method>

<method name="PathCreateTempFolder">
</method>

<method name="PathExists">
<PARAMETER name="sPath"/>
</method>

<method name="PathGetBase">
<PARAMETER name="sPath"/>
</method>

<method name="PathGetCurrentDirectory">
</method>

<method name="PathGetExtension">
<PARAMETER name="sPath"/>
</method>

<method name="PathGetFolder">
<PARAMETER name="sPath"/>
</method>

<method name="PathGetInternetCacheFolder">
</method>

<method name="PathGetLong">
<PARAMETER name="sPath"/>
</method>

<method name="PathGetName">
<PARAMETER name="sPath"/>
</method>

<method name="PathGetShort">
<PARAMETER name="sPath"/>
</method>

<method name="PathGetSpec">
<PARAMETER name="sDir"/>
<PARAMETER name="sWildcards"/>
<PARAMETER name="sFlags"/>
</method>

<method name="PathGetTempFile">
</method>

<method name="PathGetTempFolder">
</method>

<method name="PathGetTempName">
</method>

<method name="PathGetValid">
<PARAMETER name="sDir"/>
<PARAMETER name="sBase"/>
<PARAMETER name="sExt"/>
<PARAMETER name="bUnique"/>
</method>

<method name="PathSetCurrentDirectory">
<PARAMETER name="sDir"/>
</method>

<method name="RegExpContains">
<PARAMETER name="sText"/>
<PARAMETER name="sMatch"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="RegExpContainsLast">
<PARAMETER name="sText"/>
<PARAMETER name="sMatch"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="RegExpCount">
<PARAMETER name="sText"/>
<PARAMETER name="sMatch"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="RegExpExtract">
<PARAMETER name="sText"/>
<PARAMETER name="sMatch"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="RegExpReplace">
<PARAMETER name="sText"/>
<PARAMETER name="sMatch"/>
<PARAMETER name="sReplace"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="RegExpTest">
<PARAMETER name="sText"/>
<PARAMETER name="sMatch"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="ShellCreateShortcut">
<PARAMETER name="sFile"/>
<PARAMETER name="sTargetPath"/>
<PARAMETER name="sWorkingDirectory"/>
<PARAMETER name="iWindowStyle"/>
<PARAMETER name="sHotkey"/>
</method>

<method name="ShellExec">
<PARAMETER name="sCommand"/>
</method>

<method name="ShellExecute">
<PARAMETER name="sFile"/>
<PARAMETER name="sParams"/>
<PARAMETER name="sFolder"/>
<PARAMETER name="sVerb"/>
<PARAMETER name="iWindowStyle"/>
</method>

<method name="ShellExpandEnvironmentVariables">
<PARAMETER name="sText"/>
</method>

<method name="ShellGetEnvironmentVariable">
<PARAMETER name="sVariable"/>
</method>

<method name="ShellGetShortcutTargetPath">
<PARAMETER name="sFile"/>
</method>

<method name="ShellGetSpecialFolder">
<PARAMETER name="vFolder"/>
</method>

<method name="ShellInvokeVerb">
<PARAMETER name="sPath"/>
<PARAMETER name="sVerb"/>
</method>

<method name="ShellOpen">
<PARAMETER name="sPath"/>
</method>

<method name="ShellOpenWith">
<PARAMETER name="sExe"/>
<PARAMETER name="sParam"/>
</method>

<method name="ShellRun">
<PARAMETER name="sFile"/>
<PARAMETER name="iStyle"/>
<PARAMETER name="bWait"/>
</method>

<method name="ShellRunCommandPrompt">
<PARAMETER name="sDir"/>
</method>

<method name="ShellRunExplorerWindow">
<PARAMETER name="sDir"/>
</method>

<method name="ShellWait">
<PARAMETER name="sPath"/>
</method>

<method name="StringAppendToFile">
<PARAMETER name="sText"/>
<PARAMETER name="sFile"/>
<PARAMETER name="sDivider"/>
</method>

<method name="StringChomp">
<PARAMETER name="sText"/>
</method>

<method name="StringChopLeft">
<PARAMETER name="sText"/>
<PARAMETER name="iCount"/>
</method>

<method name="StringChopRight">
<PARAMETER name="sText"/>
<PARAMETER name="iCount"/>
</method>

<method name="StringContains">
<PARAMETER name="sText"/>
<PARAMETER name="sMatch"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="StringConvertToMacLineBreak">
<PARAMETER name="sText"/>
</method>

<method name="StringConvertToUnixLineBreak">
<PARAMETER name="sText"/>
</method>

<method name="StringConvertToWinLineBreak">
<PARAMETER name="sText"/>
</method>

<method name="StringCount">
<PARAMETER name="sText"/>
<PARAMETER name="sMatch"/>
</method>

<method name="StringEndsWith">
<PARAMETER name="sText"/>
<PARAMETER name="sSuffix"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="StringEqual">
<PARAMETER name="s1"/>
<PARAMETER name="s2"/>
</method>

<method name="StringEquiv">
<PARAMETER name="s1"/>
<PARAMETER name="s2"/>
</method>

<method name="StringGetASCII">
<PARAMETER name="sText"/>
</method>

<method name="StringLeft">
<PARAMETER name="sText"/>
<PARAMETER name="iCount"/>
</method>

<method name="StringLength">
<PARAMETER name="sText"/>
</method>

<method name="StringLower">
<PARAMETER name="sText"/>
</method>

<method name="StringPlural">
<PARAMETER name="sItem"/>
<PARAMETER name="iCount"/>
</method>

<method name="StringQuote">
<PARAMETER name="sText"/>
</method>

<method name="StringReplaceAll">
<PARAMETER name="sText"/>
<PARAMETER name="sMatch"/>
<PARAMETER name="sReplace"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="StringRight">
<PARAMETER name="sText"/>
<PARAMETER name="iCount"/>
</method>

<method name="StringSlice">
<PARAMETER name="sText"/>
<PARAMETER name="iStart"/>
<PARAMETER name="iEnd"/>
</method>

<method name="StringStartsWith">
<PARAMETER name="sText"/>
<PARAMETER name="sPrefix"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="StringToFile">
<PARAMETER name="sText"/>
<PARAMETER name="sFile"/>
</method>

<method name="StringToList">
<PARAMETER name="sText"/>
<PARAMETER name="sDelimiter"/>
</method>

<method name="StringTrim">
<PARAMETER name="sText"/>
</method>

<method name="StringTrimLeft">
<PARAMETER name="sText"/>
</method>

<method name="StringTrimRight">
<PARAMETER name="sText"/>
</method>

<method name="StringUnquote">
<PARAMETER name="sText"/>
</method>

<method name="StringUpper">
<PARAMETER name="sText"/>
</method>

<method name="StringWrap">
<PARAMETER name="sText"/>
<PARAMETER name="iMaxLine"/>
</method>

<method name="UrlCreate">
<PARAMETER name="sProtocol"/>
<PARAMETER name="sHost"/>
<PARAMETER name="sPath"/>
<PARAMETER name="sQuery"/>
</method>

<method name="UrlGetBaseDomain">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetExtension">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetFileName">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetFolder">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetFragment">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetFullFolder">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetHost">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetPath">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetPathPlus">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetPrePath">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetProtocol">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetQuery">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlGetSubdomain">
<PARAMETER name="sUrl"/>
</method>

<method name="UrlNormalize">
<PARAMETER name="sUrl"/>
<PARAMETER name="sBase"/>
</method>

<method name="VtArrayToJs">
<PARAMETER name="a"/>
</method>

<method name="VtArrayToList">
<PARAMETER name="a"/>
</method>

<method name="VtCopyDictionary">
<PARAMETER name="dItems"/>
</method>

<method name="VtCopyList">
<PARAMETER name="lItems"/>
</method>

<method name="VtCreateDictionary">
</method>

<method name="VtCreateFileSystemObject">
</method>

<method name="VtCreateHtmlFile">
</method>

<method name="VtCreateInternetExplorerApplication">
</method>

<method name="VtCreateList">
</method>

<method name="VtCreateRecordSet">
</method>

<method name="VtCreateRegExp">
</method>

<method name="VtCreateShellApplication">
</method>

<method name="VtCreateStream">
</method>

<method name="VtCreateVBScriptControl">
</method>

<method name="VtCreateWebRequest">
</method>

<method name="VtCreateWinHttpRequest">
</method>

<method name="VtCreateWScriptShell">
</method>

<method name="VtCreateXmlDocument">
</method>

<method name="VtDateToJs">
<PARAMETER name="dt"/>
</method>

<method name="VtDictionaryKeysToJs">
<PARAMETER name="d"/>
</method>

<method name="VtDictionaryKeysToList">
<PARAMETER name="d"/>
</method>

<method name="VtDictionaryToJs">
<PARAMETER name="d"/>
</method>

<method name="VtDictionaryToXml">
<PARAMETER name="dItems"/>
<PARAMETER name="sFile"/>
</method>

<method name="VtGetWMIObject">
</method>

<method name="VtInitDictionary">
<PARAMETER name="vValue"/>
</method>

<method name="VtInitXmlDocument">
<PARAMETER name="sXml"/>
</method>

<method name="VtListFilterByExtension">
<PARAMETER name="lPaths"/>
<PARAMETER name="lExtensions"/>
</method>

<method name="VtListFilterByRegExp">
<PARAMETER name="lItems"/>
<PARAMETER name="sMatch"/>
<PARAMETER name="bIgnoreCase"/>
</method>

<method name="VtListFilterByWildcard">
<PARAMETER name="lItems"/>
<PARAMETER name="sMatch"/>
</method>

<method name="VtListGetExtensions">
<PARAMETER name="lPaths"/>
</method>

<method name="VtListToJs">
<PARAMETER name="l"/>
</method>

<method name="VtListToString">
<PARAMETER name="lItems"/>
<PARAMETER name="sDelimiter"/>
</method>

<method name="VtStreamToFile">
<PARAMETER name="aBytes"/>
<PARAMETER name="sFile"/>
</method>

<method name="WebFetch">
<PARAMETER name="dParams"/>
</method>

<method name="WebListDownload">
<PARAMETER name="lUrls"/>
<PARAMETER name="sFolder"/>
<PARAMETER name="bUnique"/>
</method>

<method name="WebRequest">
<PARAMETER name="sType"/>
<PARAMETER name="sUrl"/>
<PARAMETER name="dData"/>
<PARAMETER name="dHeaders"/>
<PARAMETER name="sUser"/>
<PARAMETER name="sPassword"/>
</method>

<method name="WebRequestAllHeaders">
<PARAMETER name="sUrl"/>
</method>

<method name="WebRequestGet">
<PARAMETER name="sUrl"/>
<PARAMETER name="dData"/>
<PARAMETER name="dHeaders"/>
<PARAMETER name="sUser"/>
<PARAMETER name="sPassword"/>
</method>

<method name="WebRequestGetToFile">
<PARAMETER name="sUrl"/>
<PARAMETER name="dData"/>
<PARAMETER name="dHeaders"/>
<PARAMETER name="sUser"/>
<PARAMETER name="sPassword"/>
<PARAMETER name="sFile"/>
</method>

<method name="WebRequestGetToString">
<PARAMETER name="sUrl"/>
<PARAMETER name="dData"/>
<PARAMETER name="dHeaders"/>
<PARAMETER name="sUser"/>
<PARAMETER name="sPassword"/>
</method>

<method name="WebRequestHead">
<PARAMETER name="sUrl"/>
<PARAMETER name="dData"/>
<PARAMETER name="dHeaders"/>
<PARAMETER name="sUser"/>
<PARAMETER name="sPassword"/>
</method>

<method name="WebRequestHeader">
<PARAMETER name="sUrl"/>
<PARAMETER name="sHeader"/>
</method>

<method name="WebRequestPost">
<PARAMETER name="sUrl"/>
<PARAMETER name="dData"/>
<PARAMETER name="dHeaders"/>
<PARAMETER name="sUser"/>
<PARAMETER name="sPassword"/>
</method>

<method name="WebRequestPostToFile">
<PARAMETER name="sUrl"/>
<PARAMETER name="dData"/>
<PARAMETER name="dHeaders"/>
<PARAMETER name="sUser"/>
<PARAMETER name="sPassword"/>
<PARAMETER name="sFile"/>
</method>

<method name="WebRequestPostToString">
<PARAMETER name="sUrl"/>
<PARAMETER name="dData"/>
<PARAMETER name="dHeaders"/>
<PARAMETER name="sUser"/>
<PARAMETER name="sPassword"/>
</method>

<method name="WebRequestToFile">
<PARAMETER name="sType"/>
<PARAMETER name="sUrl"/>
<PARAMETER name="dData"/>
<PARAMETER name="dHeaders"/>
<PARAMETER name="sUser"/>
<PARAMETER name="sPassword"/>
<PARAMETER name="sFile"/>
</method>

<method name="WebRequestToString">
<PARAMETER name="sType"/>
<PARAMETER name="sUrl"/>
<PARAMETER name="dData"/>
<PARAMETER name="dHeaders"/>
<PARAMETER name="sUser"/>
<PARAMETER name="sPassword"/>
</method>

<method name="WebUrlContentDisposition">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlContentEncoding">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlContentLanguage">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlContentLength">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlContentLocation">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlContentType">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlDownloadFileName">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlDownloadPath">
<PARAMETER name="sUrl"/>
<PARAMETER name="sFolder"/>
<PARAMETER name="bUnique"/>
</method>

<method name="WebUrlIsHtml">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlLastModified">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlRedirect">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlServer">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlToFile">
<PARAMETER name="sUrl"/>
<PARAMETER name="sFile"/>
</method>

<method name="WebUrlToString">
<PARAMETER name="sUrl"/>
</method>

<method name="WebUrlToXml">
<PARAMETER name="sUrl"/>
</method>

<method name="XmlAppendElement">
<PARAMETER name="oParent"/>
<PARAMETER name="sName"/>
<PARAMETER name="sValue"/>
</method>

<method name="XmlCreateElement">
<PARAMETER name="oNode"/>
<PARAMETER name="sName"/>
<PARAMETER name="sValue"/>
</method>

<method name="XmlCreateFile">
<PARAMETER name="sFile"/>
</method>

<method name="XmlEnsureGetNode">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
</method>

<method name="XmlEnsureOpenFile">
<PARAMETER name="sFile"/>
</method>

<method name="XmlGetAttribute">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
<PARAMETER name="sAttribute"/>
<PARAMETER name="sDefault"/>
</method>

<method name="XmlGetNode">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
</method>

<method name="XmlGetNodeNames">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
</method>

<method name="XmlGetNodes">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
</method>

<method name="XmlGetText">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
<PARAMETER name="sDefault"/>
</method>

<method name="XmlGetValue">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
<PARAMETER name="sDefault"/>
</method>

<method name="XmlOpenFile">
<PARAMETER name="sFile"/>
</method>

<method name="XmlRemoveAttribute">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
<PARAMETER name="sAttribute"/>
</method>

<method name="XmlRemoveNode">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
</method>

<method name="XmlRemoveNodes">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
</method>

<method name="XmlSetAttribute">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
<PARAMETER name="sAttribute"/>
<PARAMETER name="sText"/>
</method>

<method name="XmlSetText">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
<PARAMETER name="sText"/>
</method>

<method name="XmlSetValue">
<PARAMETER name="sFile"/>
<PARAMETER name="sPath"/>
<PARAMETER name="sValue"/>
</method>

<method name="XmlToVtDictionary">
<PARAMETER name="sFile"/>
</method>

</public>

<implements type="Behavior" id="Behavior"/>

<script language="VBScript">
<![CDATA[
Function DialogBrowseForFolder(sFolder)
' Specify a folder pathDialogBrowseForFolder = ""
Set oShell = CreateObject("Shell.Application")
h = 0
iOptions = &H0001 ' Only file system folders can be selected
iOptions = iOptions Or &H0010 ' Shows an edit box in the dialog box for the user to type the name of an item
iOptions = iOptions Or &H0020 ' Validate the name typed in the edit box
iOptions = iOptions Or &H4000 ' Allows browsing for everything

If Len(sFolder) > 0 Then
sOldFolder = PathGetCurrentDirectory
vDir = sFolder
Else
sOldFolder = ""
vDir = &h11 ' (17). My Computer-the virtual folder that contains everything on the local computer: storage devices, printers, and Control Panel
' vDir = ""
End If

Set oFolder = Nothing
On Error Resume Next
Set oFolder = oShell.BrowseForFolder(h, sTitle, iOPTIONS, vDir)
On Error GoTo 0

If oFolder is Nothing Then
DialogBrowseForFolder = InputBox("Folder:", "Input", sFolder)
Else
Set oItem = oFolder.Self
DialogBrowseForFolder = oItem.Path
End If

If Len(sOldFolder) > 0 Then PathSetCurrentDirectory sOldFolder
Set oItem = Nothing
Set oFolder = Nothing
Set oShell = Nothing
End Function

Function DialogConfirm(sTitle, sMessage, sDefault)
' Get choice from a standard Yes, No, or Cancel message box

Dim iFlags,iChoice

DialogConfirm = ""
iFlags = vbYesNoCancel
iFlags = iFlags or vbQuestion	' 32 query icon
iFlags = iFlags Or vbSystemModal ' 4096	System modal
If sTitle = "" Then sTitle = "Confirm"
If sDefault = "N" Then iFlags = iFlags Or vbDefaultButton2
iChoice = MsgBox(sMessage, iFlags, sTitle)
If iChoice = vbCancel Then Exit Function

If iChoice = vbYes Then
DialogConfirm = "Y"
Else
DialogConfirm = "N"
End If
End Function

Function DialogInput(sTitle, sField, sValue)
' Get input from a single edit box

DialogInput = ""
If sField <> "" And Right(sField, 1) <> ":" Then sField = sField & ":"
DialogInput = InputBox(sField, sTitle, sValue)
End Function

Function DialogShow(oTitle, oText)
' Show a title and message

Dim iFlags
Dim sTitle, sText

' Show string version of two parameters in the title and prompt of a message box

sTitle = VtStr(oTitle)
sText = VtStr(oText)
If sTitle = "Alert" Or sTitle = "Error" Then
iFlags = vbExclamation ' 48	warning icon
Else
iFlags = vbInformation ' 64 information icon
End If

iFlags = iFlags Or vbSystemModal ' 4096	System modal
MsgBox sText, iFlags, sTitle
End Function

Function FileIsUnicode(sFile)
' Test whether file is Unicode
Const ForReading = 1
Const ASCII = 0
Const Unicode = -1
Dim oSystem, oFile
Dim s1, s2

FileIsUnicode = False
If FileGetSize(sFile) < 2 Then Exit Function

Set oSystem = CreateObject("Scripting.FileSystemObject")
Set oFile = oSystem.OpenTextFile(sFile, ForReading, ASCII)
s1 = Hex(AscB(MidB(oFile.Read(1), 1, 1)))
s2 = Hex(AscB(MidB(oFile.Read(1), 1, 1)))
oFile.Close
' msgbox xutf16, 0, s1 & s2
If s1 & s2 = xUTF16 Then FileIsUnicode = True
If s2 & s1 = xUTF16 Then FileIsUnicode = True
Set oFile = Nothing
Set oSystem = Nothing
End Function

Function FileIsUTF8(sFile)
' Test whether file is UTF-8
Const ForReading = 1
Const ASCII = 0
Const Unicode = -1
Dim oSystem, oFile
Dim s1, s2, s3

FileIsUTF8 = False
If FileGetSize(sFile) < 3 Then Exit Function

Set oSystem = CreateObject("Scripting.FileSystemObject")
Set oFile = oSystem.OpenTextFile(sFile, ForReading, ASCII)
s1 = Hex(AscB(MidB(oFile.Read(1), 1, 1)))
s2 = Hex(AscB(MidB(oFile.Read(1), 1, 1)))
s3 = Hex(AscB(MidB(oFile.Read(1), 1, 1)))
oFile.Close
If s1 & s2 & s3 = xUTF8 Then FileIsUTF8 = True
Set oFile = Nothing
Set oSystem = Nothing
End Function

Function ProcessGetModules()
' Return collection of process modules

Dim oProcesses, oProcess, oModules

Set oModules = CreateDictionary

Set oProcesses = ProcessQueryName("")
For Each oProcess in oProcesses
oModules.Add oProcess.ProcessID, oProcess.name
Next
Set ProcessGetModules = oModules
Set oProcesses = Nothing
End Function

Function ProcessIsModuleActive(sName)
' Test if process is active in memory

Dim oProcesses

Set oProcesses = ProcessQueryName(sName)
ProcessIsModuleActive = False
If oProcesses.Count > 0 then ProcessIsModuleActive = True
End Function

Function ProcessQueryName(sName)
' Returns a collection of 0 or more Win32_Process objects.
' If sName is null, all processes are returned; otherwise, just the matching ones.
' If sName contains no dot, .exe is assumed.
' Note:  Only ProcessID and Name are pulled here, for efficiency.

dim oWMIService
dim sQuery, sComputer

Set ProcessQueryName = Nothing
sComputer = "."
Set oWMIService = Nothing
On Error Resume Next
Set oWMIService = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & sComputer & "\root\cimv2")
On Error GoTo 0
If oWMIService Is Nothing Then Exit Function

' Only the properties needed by this class are pulled here.
sQuery = "select name,ProcessID from win32_process"
If len(sName) > 0 then
sQuery = sQuery & " where name='" & sName
If inStr(sName, ".") = 0 then sQuery = sQuery & ".exe"
sQuery = sQuery & "'"
end if

On Error Resume Next
Set ProcessQueryName = oWMIService.ExecQuery(sQuery)
On Error GoTo 0
end Function

Function ProcessTerminateModule(sName)
' Terminate a process by name.
' If sName contains no dot, .exe is assumed.
' Returns True on success and False on failure.
' Failure includes failure to find exactly one matching process.

Dim iResult
Dim oProcesses, oProcess
processTerminateModule = False
Set oProcesses = ProcessQueryName(sName)
If oProcesses Is Nothing Then exit Function
If oProcesses.Count <> 1 then exit Function

for each oProcess in oProcesses
iResult = oProcess.Terminate
' Non-zero result means error terminating process.
If iResult <> 0 then exit Function
Exit For
next
processTerminateModule = True
End Function

Function RegistryGetString(iRootKey, sSubKey, sValueName)
' Get a registry string

Dim oRegistry
Dim sValueData

RegistryGetString = ""
Set oRegistry = Nothing
On Error Resume Next
Set oRegistry = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
On Error GoTo 0
If oRegistry Is Nothing Then Exit Function

oRegistry.GetStringValue iRootKey, sSubKey, sValueName, sValueData
If Typename(sValueData) <> "Null" Then RegistryGetString = sValueData
Set oRegistry = Nothing
End Function

Function RegistryRead(sKey)
' Get a string from the registry

Dim oShell

RegistryRead = ""
Set oShell =CreateObject("Wscript.Shell")
On Error Resume Next
RegistryRead =oShell.RegRead(sKey)
Set oShell = Nothing
End Function

Function RegistrySetString(iRootKey, sSubKey, sValueName, sValueData)
' Set a registry string
Dim oRegistry

RegistrySetString = False
Set oRegistry = Nothing
On Error Resume Next
Set oRegistry = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
On Error GoTo 0
If oRegistry Is Nothing Then Exit Function

RegistrySetString = oRegistry.SetStringValue(iRootKey, sSubKey, sValueName, sValueData)
Set oRegistry = Nothing
End Function

Function RegistryWrite(sKey, sValue)
' Write a string to the registry

Dim oShell

RegistryWrite = False
Set oShell =CreateObject("Wscript.Shell")
On Error Resume Next
RegistryWrite =oShell.RegWrite(sKey, sValue, "REG_SZ")
On Error GoTo 0
Set oShell = Nothing
End Function

Function StringIsUnicode(sText)
' Test whether a string is Unicode
Dim i, iCount, iCode
Dim s, s1, s2

StringIsUnicode = False
If Len(sText) < 2 Then Exit Function

s1 = Hex(AscB(MidB(sText, 1, 1)))
s2 = Hex(AscB(MidB(sText, 2, 1)))
If 0 then
' If ((s1 & s2) = xUTF16) Or ((s2 & s1) = xUTF16) Then
StringIsUnicode = True
Exit Function
End If

iCount = Min(1000, Len(sText))
For i = 1 To iCount
s = Mid(sText, i, 1)
' iCode = VtStr("&h" & ASCW(s))
iCode = ASCW(s)
If iCode > 255 Then
StringIsUnicode = True
Exit Function
End If
Next
End Function

Function StringIsUTF8(sText)
' Test whether a string is UTF-8
Dim s1, s2, s3

StringIsUTF8 = False
If Len(sText) < 3 Then Exit Function

s1 = Hex(AscB(MidB(sText, 1, 1)))
s2 = Hex(AscB(MidB(sText, 2, 1)))
s3 = Hex(AscB(MidB(sText, 3, 1)))
If s1 & s2 & s3 = xUTF8 Then StringIsUTF8 = True
End Function

Function StringPrependUTF8(sText)
' Add UTF8 prefix to string

Dim i
Dim s, sPrefix

sPrefix = ""
For i = 1 To Len(xUTF8) Step 2
s = Mid(xUTF8, i, 2)
s = "&H" & s
sPrefix = sPrefix & ChrB(s)
Next

StringPrependUTF8 = sPrefix & sText
End Function

Function StringReplace(sText, sMatch, sReplace, bIgnoreCase)
' Replace text

Dim iCompare
If bIgnoreCase Then
iCompare = vbTextCompare
Else
iCompare = vbBinaryCompare
End If

StringReplace = Replace(sText, sMatch, sReplace, 1, -1, iCompare)
End Function ' StringReplace method

Function VBSEval(sCode, v1, v2, v3, v4)
' Evaluate VBScript code

Dim aLines
Dim iBound
Dim sEval, sExec

aLines = Split(sCode, vbCrLf)
iBound = UBound(aLines)
sEval = aLines(iBound)
If iBound > 0 Then
Redim Preserve aLines(iBound - 1)
sExec = Join(aLines, vBCrLf)
Execute sExec
End If
VBSEval = Eval(sEval)
End Function

Function VtSleep(iMilliseconds)
' Sleep for iMilliseconds

WScript.Sleep iMilliseconds
End Function

Function VtStr(sText)
VtStr = "" & sText
End Function

Function VtTrim(sText)
' Trim space from both ends of a string

VtTrim = Trim(sText)
End Function ' VtTrim method

Function VtTypeName(vVariant)
' Get variant subtype

VtTypeName = TypeName(vVariant)
End Function ' VtTypeName method
]]>
</script>

<script language="JScript">
<![CDATA[
// Constants

var xDebugCount = 0
var ioForReading = 1
var ioForWriting = 2
var ioForAppending = 8

var formatTristateUseDefault = -2 // Open as System default
var formatTristateTrue = -1 // Open as Unicode
var formatTriStateFalse = 0 // Open as ASCII

var vbBlack = 0x00 // Black
var vbRed = 0xFF // Red
var vbGreen = 0xFF00 // Green
var vbYellow = 0xFFFF // Yellow
var vbBlue = 0xFF0000 // Blue
var vbMagenta = 0xFF00FF// Magenta
var vbCyan = 0xFFFF00// Cyan
var vbWhite = 0xFFFFFF // White

var vbBinaryCompare = 0 // Perform a binary comparison
var vbTextCompare = 1 // Perform a textual comparison

var vbSunday = 1 // Sunday
var vbMonday = 2 // Monday
var vbTuesday = 3 // Tuesday
var vbWednesday = 4 // Wednesday
var vbThursday = 5 // Thursday
var vbFriday = 6 // Friday
var vbSaturday = 7 // Saturday
var vbUseSystemDayOfWeek = 0 // Use the day of the week specified in your system settings
var vbFirstJan = 11 // Use the week in which January = 1 // occurs (default)
var vbFirstFourDays = 2 // Use the first week that has at least four days in the new
var vbFirstFullWeek = 3 // Use the first full week of the year
var vbGeneralDate = 0 // Display a date and/or time. For real numbers, display a date and
var vbLongDate = 1 // Display a date using the long date format specified in your
var vbShortDate = 2 // Display a date using the short date format specified in your
var vbLongTime = 3 // Display a time using the long time format specified in your
var vbShortTime = 4 // Display a time using the short time format specified in your
var vbObjectError = -2147221504 // User-defined error numbers should be greater than this

var vbOKOnly = 0 // Display OK button only
var vbOKCancel = 1 // Display OK and Cancel buttons
var vbAbortRetryIgnore = 2 // Display Abort, Retry, and Ignore buttons
var vbYesNoCancel = 3 // Display Yes, No, and Cancel buttons
var vbYesNo = 4 // Display Yes and No buttons
var vbRetryCancel = 5 // Display Retry and Cancel buttons
var vbCritical = 16 // Display Critical Message icon
var vbQuestion = 32 // Display Warning Query icon
var vbExclamation = 48 // Display Warning Message icon
var vbInformation= 64 // Display Information Message icon
var vbDefaultButton1 = 0 // First button is the default
var vbDefaultButton2 = 256 // Second button is the default
var vbDefaultButton3 = 512 // Third button is the default
var vbDefaultButton4 = 768 // Fourth button is the default
var vbApplicationModal = 0 // Application modal. The user must respond to the message box
var vbSystemModal = 4096 // System modal
var vbOK = 1 // OK button was clicked
var vbCancel = 2 // Cancel button was clicked
var vbAbort = 3 // Abort button was clicked
var vbRetry = 4 // Retry button was clicked
var vbIgnore = 5 // Ignore button was clicked
var vbYes = 6 // Yes button was clicked
var vbNo = 7 // No button was clicked
var vbCr = '\r' // carriage return
var vbFormFeed = '\f' // form feed
var vbLf = '\n' // line feed
var vbNewLine = '\r\n' // platform-specific new line
var vbNullChar = 0x000 // null character
var vbNullString = '\0x0000'
var vbTab = '\t' // tab
var vbVerticalTab = '\v' // vertical tab
var vbUseDefault = -2 // Use default from computer's regional settings
var vbtrue = -1 // true
var vbfalse = 0 // false
var vbEmpty = 0 // Uninitialized (default)
var vbNull = 1 // Contains no valid data
var vbInteger = 2 // Integer subtype
var vbLong = 3 // Long subtype
var vbSingle = 4 // Single subtype
var vbDouble = 5 // Double subtype
var vbCurrency = 6 // Currency subtype
var vbDate = 7 // Date subtype
var vbString = 8 // String subtype
var vbObject = 9 // Object
var vbError = 10 // Error subtype
var vbBoolean = 11 // Boolean subtype
var vbVt = 12 // Vt (used only for arrays of Vts)
var vbDataObject = 13 // Data access object
var vbDecimal = 14 // Decimal subtype
var vbByte = 17 // Byte subtype
var vbArray = 8192 // Array

var vbUseSystem = 0 // Use National Language Support (NLS) API setting
var vbDefaultButton = 1 // = 0 // First button is default
var vbCrLf = '\r\n'
var xMaxPath = 260
var xSpace = ' '
var xMute = ''
var xComma = ','
var xCommaSpace = ', '
var xBar = '|'
var xQuote = '"'
var xApostrophe = "'"
var xSlash = '/'
var xBackslash = '\\'
var xEquals = '='
var xColon = ':'
var xSemicolon = ';'
var xLessThan = '<'
var xGreaterThan = '>'
var xLeftBrace = '{'
var xRightBrace = '}'
var xUTF = 8 // 'EFBBBF'
var xSectionBreak = vbCrLf + '----------' + vbCrLf + vbFormFeed + vbCrLf
var xEndOfDocument = vbCrLf + '----------' + vbCrLf + 'End of Document' + vbCrLf

var adVarWChar = 202

var adAffectCurrent = 1 //

var adSaveCreateNotExist = 1 // Default, create if absent
var adSaveCreateOverWrite = 2 // create even if present
var adTypeBinary = 1 // Binary
var adTypeText = 2 // default, text

var adAffectGroup = 2 //
var adAffectAll = 3 //
var adFilterNone = 0 //
var adFilterPendingRecords = 1 //
var adFilterAffectedRecords = 2 //
var adFilterFetchedRecords = 3 //
var adFilterConflictingRecords = 5 //
var adClipString = 2 //
var adUseServer = 2 //
var adUseClient = 3 //
var adOpenForwardOnly = 0 //
var adOpenKeySet = 1 //
var adOpenDynamic = 2 //
var adOpenStatic = 3 //
var adLockReadOnly = 1 //
var adLockOptimistic = 3 //
var adBatchOptimistic = 4 //
var adCmdText = 1 //
var adCmdTableDirect = 512 //
var adExecuteNoRecords = 128 //
var adSearchBackward = -1 //
var adSearchForward	= 1 //
var adBookmarkCurrent = 0 //
var adBookmarkFirst = 1 //
var adBookmarkLast = 2 //
var adPosBOF = -2 //
var adPosEOF = -3 //
var adPosUnknown = -1 //

// Functions

function FileCopy(sSource, sTarget) {
// Copy source to destination file, replacing if it exists

if (!FileDelete(sTarget)) return false

var oSystem =VtCreateFileSystemObject()
try {
oSystem.CopyFile(sSource, sTarget)
}
catch (e) { }
oSystem = null
return FileExists(sTarget)
} // FileCopy method

function FileDelete(sFile) {
// Delete a file if it exists, and test whether it is subsequently absent
// either because it was successfully deleted || because it was!present in the first place

if (!FileExists(sFile)) return true
var oSystem =VtCreateFileSystemObject()
try {
oSystem.DeleteFile(sFile, true)
}
catch (e) {}

oSystem = null
return !FileExists(sFile)
} // FileDelete method

function FileExists(sFile) {
// Test whether File exists

var oSystem =VtCreateFileSystemObject()
var bReturn = !oSystem.FolderExists(sFile) && oSystem.FileExists(sFile)

oSystem =null
return bReturn
} // FileExists method

function FileGetDate(sFile) {
// Get date of a file

if (!FileExists(sFile)) return null

var oSystem =VtCreateFileSystemObject()
var oFile =oSystem.GetFile(sFile)
var dtReturn =oFile.DateLastModified

oFile = null
oSystem = null
return dtReturn
} // FileGetDate method

function FileGetSize(sFile) {
// Get size of a file

if (!FileExists(sFile)) return 0

var oSystem =VtCreateFileSystemObject()
var oFile =oSystem.GetFile(sFile)
var iReturn =oFile.size

oFile = null
oSystem = null
return iReturn
} // FileGetSize method

function FileGetType(sFile) {
// Get file type

if (!FileExists(sFile)) return null

var oSystem =VtCreateFileSystemObject()
var oFile =oSystem.GetFile(sFile)
var sReturn =oFile.Type

oFile = null
oSystem = null
return sReturn
} // FileGetType method

function FileMove(sSource, sTarget) {
// Move source to destination file, replacing if it exists

if (!FileDelete(sTarget)) return false

var oSystem =VtCreateFileSystemObject()
try {
oSystem.MoveFile(sSource, sTarget)
}
catch (e) {}

oSystem = null
return FileExists(sTarget)
} // FileMove method

function FileToString(sFile) {
// Get content of text file

if (FileGetSize(sFile) == 0) return xMute

var oSystem =VtCreateFileSystemObject()
var bCreate = false
var oFile = oSystem.OpenTextFile(sFile, ioForReading, bCreate, formatTriStateFalse)
var sReturn =oFile.ReadAll()
oFile.Close()

oFile = null
oSystem = null
return sReturn
} // FileToString method

function FolderCopy(sSource, sTarget) {
// Copy source to destination Folder, replacing if it exists

if (!FolderExists(sTarget)) return false

var oSystem =VtCreateFileSystemObject()
try {
oSystem.CopyFolder(sSource, sTarget)
}
catch (e) {}

oSystem = null
return FolderExists(sTarget)
} // FolderCopy method

function FolderCreate(sFolder) {
// Create folder

if (FolderExists(sFolder)) return true

var oSystem =VtCreateFileSystemObject()
try {
oSystem.CreateFolder(sFolder)
}
catch (e) {}

oSystem = null
return FolderExists(sFolder)
} // FolderCreate method

function FolderDelete(sFolder) {
// Delete a Folder if it exists, and test whether it is subsequently absent
// either because it was successfully deleted || because it was!present in the first place

if (!FolderExists(sFolder)) return true

var oSystem =VtCreateFileSystemObject()
try {
oSystem.DeleteFolder(sFolder, true)
}
catch (e) {}

oSystem = null
return !FolderExists(sFolder)
} // FolderDelete method

function FolderExists(sFolder) {
// Test whether folder exists

var oSystem =VtCreateFileSystemObject()
var bReturn =oSystem.FolderExists(sFolder)

oSystem =null
return bReturn
} // Folder exists method

function FolderGetDate(sFolder) {
// Get date of a Folder

if (!FolderExists(sFolder)) return null

var oSystem =VtCreateFileSystemObject()
var oFolder =oSystem.GetFolder(sFolder)
var dtReturn =oFolder.DateLastModified

oFolder = null
oSystem = null
return dtReturn
} // FolderGetDate method

function FolderGetSize(sFolder) {
// Get size of folder, summing the sizes of files and subfolders it contains

if (!FolderExists(sFolder)) return 0

var oSystem =VtCreateFileSystemObject()
var oFolder =oSystem.GetFolder(sFolder)
var iReturn =oFolder.size

oFolder = null
oSystem = null
return iReturn
} // FolderGetSize method

function FolderMove(sSource, sTarget) {
// Move source to destination Folder, replacing if it exists

if (!FolderExists(sSource)) return false

var oSystem =VtCreateFileSystemObject()
try {
oSystem.MoveFolder(sSource, sTarget)
}
catch (e) {}

oSystem = null
return FolderExists(sTarget)
} // FolderMove method

function HtmlDecodeString(sText) {
// Decode a string from HTML or XML

var sReturn = StringReplace(sText, '&lt;', '<', true)
sReturn = StringReplace(sReturn, '&gt;', '>', true)
sReturn = StringReplace(sReturn, '&amp;', '&', true)
sReturn = StringReplace(sReturn, '&sc;', ';', true)
return sReturn
} // HtmlDecodeString method

function HtmlEncodeString(sText) {
// Encode a string for HTML or XML

var sReturn = StringReplace(sText, '<', '&lt;', true)
sReturn = StringReplace(sReturn, '>', '&gt;', true)
sReturn = StringReplace(sReturn, '&', '&amp;', true)
sReturn = StringReplace(sReturn, ';', '&sc;', true)
return sReturn
} // HtmlEncodeString method

function HtmlGetLinks(sUrl, bIncludeDownloadName) {
// Get a list of two-item lists containing the URL and text of a link

var lLinks = VtCreateList()
var dUrls = VtCreateDictionary()
var HKCU = 0x80000001 // HKEY_CURRENT_USER
var sRegPath = 'HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\\Disable Script Debugger\\'
var sOldRegValue = RegistryGetString(HKCU, 'Software\\Microsoft\\Internet Explorer\\Main', 'Disable Script Debugger')
if (!StringEquiv(sOldRegValue, 'yes')) RegistrySetString(HKCU, 'Software\\Microsoft\\Internet Explorer\\Main', 'Disable Script Debugger', 'yes')
var oDoc = VtCreateHtmlFile()
// DialogShow('url', sUrl)
var bIsUrl = false
if (FileExists(sUrl)) var sBody = FileToString(sUrl)
else if (RegExpTest(sUrl, '^\\w+://\\S+$', true)) {
// else if (RegExpTest(sUrl, '\\w+://\\S+', true)) {
var sBody = WebUrlToString(sUrl)
bIsUrl = true
}
else var sBody = sUrl

// DialogShow('body length', sBody.length)
oDoc.write(sBody)
// DialogShow('IsUrl', bIsUrl.toString())

// Does not work
// var sUrl = oDoc.URL
// var sUrl = oDoc.location
// var sUrl = oDoc.address
// var sUrl = oDoc.hRef

var sBase = xMute
if (bIsUrl) {
// sBase = UrlGetPrePath(sUrl)
sBase = sUrl
// DialogShow('sBase', sBase)
var sTitle = oDoc.title
// DialogShow('title', sTitle)
dUrls.Add(sUrl, '')
var lLink = VtCreateList()
lLink.Add(sUrl)
lLink.Add(sTitle)
lLink.Add(WebUrlDownloadFileName(sUrl))
lLinks.Add(lLink)
}

var oLinks = oDoc.links
// var oLinks = oDoc.all.tags('a')
// DialogShow('links', oLinks.length)
// DialogShow(sUrl, sBase)
// These do not work
// JsPrint('domain=' + oDoc.domain)
// JsPrint('hostname=' + oDoc.hostname)
for (var i = 0; i < oLinks.length; i++) {
// ShellOpenWith('SayLine.exe', i.toString())
var oLink = oLinks.item(i)
var sUrl = oLink.href
if (!sUrl) continue
var sText = oLink.innerText
// if (sText == 'About the FCC') DialogShow('url', sUrl)
if (!sText) sText = xMute
if (JsIsUndefined(sText)) sText = xMute
if (dUrls.Exists(sUrl)) continue
// if (!i) DialogShow(sBase.length, '')
if (bIsUrl) sUrl = UrlNormalize(sUrl, sBase)
// else sUrl = UrlNormalize(sUrl, xMute)
if (sUrl.indexOf(':') == -1) continue
if (dUrls.Exists(sUrl)) continue
dUrls.Add(sUrl, '')

var lLink = VtCreateList()
lLink.Add(sUrl)
lLink.Add(sText)
if (bIncludeDownloadName) lLink.Add(WebUrlDownloadFileName(sUrl))
lLinks.Add(lLink)
}

oDoc.close()
if (!StringEquiv(sOldRegValue, 'yes')) RegistrySetString(HKCU, 'Software\\Microsoft\\Internet Explorer\\Main', 'Disable Script Debugger', sOldRegValue)

lLink = null
dUrls = null
oDoc = null
//DialogShow('my links', lLinks.Count)
return lLinks
} // HtmlGetLinks method

function HtmlGetLinkTextAndUrls(sUrl) {
// Get link text and urls of a web page

// DialogShow('my url', sUrl)
var sReturn = xMute
var lLinks = HtmlGetLinks(sUrl, true)
DialogShow('Now links', lLinks.Count)
var iCount = lLinks.Count
for (var i = 0; i < iCount; i++) {
var lLink = lLinks.Item(i)
var sLinkUrl = lLink.Item(0)
var sLinkText = lLink.Item(1)
var sLinkFileName = lLink.Item(2)
// ShellOpenWith('SayLine.exe', i.toString())
sReturn += sLinkText + ' = ' + sLinkUrl + ' = ' + sLinkFileName + '\r\n'
// sReturn += sLinkText + '\r\n'
}
// DialogShow('links', lLinks.Count)

if (!iCount) {
var lUrls = RegExpExtract(sUrl, '\\w+:\\/\\/[^"\\s]*', false)
sReturn = VtListToString(lUrls, '\r\n')
if (sReturn) sReturn = ' = ' + StringReplace(sReturn, '\r\n', '\r\n = ', true)
iCount = lUrls.Count
}

if (sReturn) {
sReturn = StringPlural('Url', iCount) + '\r\n' + sReturn
sReturn = StringTrim(sReturn)
sReturn = StringReplace(sReturn, '\r\n', '\r\n\r\n', false) + '\r\n'
}

lLink = null
lLinks = null
return sReturn
} // HtmlGetLinkTextAndUrls method

function HtmlGetTableText(sUrl, iTable) {
// Get the text of an HTML table specified by number, or null for all of them

var HKCU = 0x80000001 // HKEY_CURRENT_USER
var sRegPath = 'HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\\Disable Script Debugger\\'
var sOldRegValue = RegistryGetString(HKCU, 'Software\\Microsoft\\Internet Explorer\\Main', 'Disable Script Debugger')
if (!StringEquiv(sOldRegValue, 'yes')) RegistrySetString(HKCU, 'Software\\Microsoft\\Internet Explorer\\Main', 'Disable Script Debugger', 'yes')
var oDoc = VtCreateHtmlFile()
var sBody = WebUrlToString(sUrl)
oDoc.write(sBody)
var oTables = oDoc.all.tags('table')

var sText = xMute
if (JsIsNull(iTable)) {
for (var i = 0; i < oTables.length; i ++ ) {
var oTable = oTables.item(i)
sText += oTable.innerText + vbCrLf + vbCrLf
}
}
else {
var oTable = oTables.item(iTable)
sText = oTable.innerText + vbCrLf + vbCrLf
}
oDoc.close()
if (!StringEquiv(sOldRegValue, 'yes')) RegistrySetString(HKCU, 'Software\\Microsoft\\Internet Explorer\\Main', 'Disable Script Debugger', sOldRegValue)

oTable = null
oTables = null
oDoc = null
return sText
} // HtmlGetTableText method

function HtmlGetText(sUrl, bAddHeader) {
// Get the text of an HTML page, optionally including the source URL at the top

var HKCU = 0x80000001 // HKEY_CURRENT_USER
var sRegPath = 'HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main\\Disable Script Debugger\\'
var sOldRegValue = RegistryGetString(HKCU, 'Software\\Microsoft\\Internet Explorer\\Main', 'Disable Script Debugger')
if (!StringEquiv(sOldRegValue, 'yes')) RegistrySetString(HKCU, 'Software\\Microsoft\\Internet Explorer\\Main', 'Disable Script Debugger', 'yes')
var oDoc = VtCreateHtmlFile()
// DialogShow('url', sUrl)
if (FileExists(sUrl)) var sBody = FileToString(sUrl)
else if (RegExpTest(sUrl, '^\\w+://\\S+$', true)) var sBody = WebUrlToString(sUrl)
else var sBody = sUrl

oDoc.write(sBody)
var sText = StringTrim(oDoc.body.innerText)
var sTitle = StringTrim(oDoc.title)
if (sText && sTitle) sText = sTitle + '\r\n\r\n' + sText
if (bAddHeader && sText) sText = 'From the web page\r\n' + sUrl + '\r\n\r\n' + sText
if (sText) sText += '\r\n'
oDoc.close()

if (!StringEquiv(sOldRegValue, 'yes')) RegistrySetString(HKCU, 'Software\\Microsoft\\Internet Explorer\\Main', 'Disable Script Debugger', sOldRegValue)

oDoc = null
return sText
} // HtmlGetText method

function HtmlGetUrls(sUrl) {
// Get a list of URLs linked to a web page

var lReturn = VtCreateList()
if (RegExpTest(sUrl, '^\\w+://\\S+$', true)) lReturn.Add(sUrl)
var lLinks = HtmlGetLinks(sUrl, false)
// DialogShow('links', lLinks.Count)
for (var i = 0; i < lLinks.Count; i++) {
var lLink = lLinks.Item(i)
var sLinkUrl = lLink.Item(0)
// sLinkUrl = UrlNormalize(sLinkUrl, sUrl)
if (!lReturn.Contains(sLinkUrl)) lReturn.Add(sLinkUrl)
}

lLink = null
lLinks = null
return lReturn
} // HtmlGetUrls method

function JsDictionaryToEncodedString(d) {
// Convert dictionary to string with http encoding
var sReturn = ''
for (var sKey in d) {
var sValue = d[sKey]
var sComponent = '' + encodeURIComponent(sKey) + '=' + encodeURIComponent(sValue)
// var sComponent = '' + sKey + '=' + sValue
if (sReturn.length > 0) sReturn += '&'
sReturn += sComponent
}
return sReturn
} // JsDictionaryToEncodedString method

function JsDictionaryToVt(d) {
// Convert JScript dictionary to variant

var dReturn = VtCreateDictionary()
for (var sKey in d) dReturn.Add(sKey, d[sKey])
return dReturn
} // JsDictionaryToVt method

function JsEval(sCode, o1, o2, o3, o4) {
// Evaluate sCode, optionally referencing up to 4 parameters of any type, and return the result

return eval(sCode, "unsafe")
} // JsEval method

function JsInitArray(oValue, iLength) {
// Initialize a JScript array

var aReturn = []
for (var i = 0; i < iLength; i++) aReturn[i] = oValue
return aReturn
} // JsInitArray method

function JsInspectObject(sName, oValue) {
// Report on type of object and its subobjects

var sReturn = ''
var sType = typeof(oValue)
if (sType != 'object' || oValue == null) sReturn += sType + ', ' + sName + ', ' + oValue + '\n'
else if (typeof(oValue.length) == 'number') {
sReturn += 'array, ' + sName + '\n'
for (var i = 0; i < oValue.length; i++) {
// sReturn += 'index ' + i + '\n'
var oItem = oValue[i]
sReturn += JsInspectObject(sName + '.' + i, oItem)
}
}
else {
sReturn += 'object, ' + sName+ '\n'
for (var sAttribute in oValue) {
// sReturn += 'attribute ' + sAttribute + '\n'
var oItem = oValue[sAttribute]
sReturn += JsInspectObject(sName + '.' + sAttribute, oItem)
}
}
return sReturn
} // JsInspectObject method

function JsIsBlank(sText) {
// Test if string is empty or white space

var s = JsString(sText)
if (s.length) s = s.replace(xSpace, xMute)
if (s.length) s = s.replace(vbTab, xMute)
if (s.length) s = s.replace(vbCr, xMute)
if (s.length) s = s.replace(vbLf, xMute)
if (s.length) s = s.replace(vbFormFeed, xMute)
if (s.length) s = s.replace(vbVerticalTab, xMute)

if (!s.length) return true
else return false
} // JsIsBlank method

function JsIsMute(o) {
// test for empty string

if (typeof(o) != 'string') return false
if (o == vbFormFeed) return true
else return false
} // JsIsMute method

function JsIsNull(o) {
// Test for null

return o == null
} // JsIsNull method

function JsIsObject(o) {
// Test for object

return ((typeof(o) == 'object') && (o != null))
} // JsIsObject method

function JsIsUndefined(o) {
// Test whether object is undefined

return (typeof(o) == 'undefined')
} // JsIsUndefined method

function JsMin(i, j) {
// Return minimum of two numbers

if (i <= j) return i
return j
} // JsMin method

function JSNumber(o) {
// Convert to JScript number

var nReturn = 0
try {
nReturn = 0 + o
}
catch (e) {}
return nReturn
} // JSNumber method

function JsObjectToVt(oValue) {
// Convert JScript object to variant

var sType = typeof(oValue)
if (sType != 'object' || oValue == null) return oValue
else if (typeof(oValue.length) == 'number') {
var a = VtCreateList()
for (var i = 0; i < oValue.length; i++) {
var oItem = oValue[i]
a.Add(JsObjectToVt(oItem))
}
return a
}
else {
var d = VtCreateDictionary()
for (var sAttribute in oValue) {
oItem = oValue[sAttribute]
d.Add(sAttribute, JsObjectToVt(oItem))
}
return d
}
} // JsObjectToVt method

function JsPrint(o) {
// Print to screen using console mode of Windows Script Host

return WScript.Echo(o)
// return WriteLine(o)
} // JsPrint method

function JsPrintObject(sName, oValue) {
// Print type of object and its subobjects

var sType = typeof(oValue)
if (sType != 'object' || oValue == null) JsPrint(sType + ', ' + sName + ', ' + oValue)
else if (typeof(oValue.length) == 'number') {
JsPrint('array, ' + sName)
for (var i = 0; i < oValue.length; i++) {
var oItem = oValue[i]
JsPrintObject(sName + '.' + i, oItem)
}
}
else {
JsPrint('object, ' + sName)
for (var sAttribute in oValue) {
var oItem = oValue[sAttribute]
JsPrintObject(sName + '.' + sAttribute, oItem)
}
}
} // JsPrintObject method

function JsSplit(sText, sDelimiter) {
// Split but ensure an empty array for empty text

if (!sText) return []
return sText.split(sDelimiter)
} // JsSplit method

function JsSplitLines(sText) {
// JsSplit by line feeds after chomping

var sText = StringConvertToUnixLineBreak(sText)
sText = StringChomp(sText)
return JsSplit(sText, '\n')
} // JsSplitLines method

function JsString(o) {
// Convert to a JScript string

var sReturn = xMute
try {
sReturn = xMute + o
}
catch (e) {}
if (!sReturn) sReturn = xMute
return sReturn
} // JsString method

function JsToVt(sJs) {
// Convert string in JavaScript Object Notation to COM exchange format

var sJs = '(' + sJs + ')'
var oValue = eval(sJs)
return JsObjectToVt(oValue)
} // JsToVt method

function PathCombine(sFolder, sName) {
// Combine folder and name to form a valid path

var sReturn = sFolder + '\\' + sName
sReturn = sReturn.replace('\\\\', '\\')
return sReturn
} // PathCombine method

function PathCreateTempFolder() {
// Create temporary folder and return its full path

var sFolder = PathCombine(PathGetTempFolder(), PathGetTempName())
return FolderCreate(sFolder)
} // PathCreateTempFolder method

function PathExists(sPath) {
// Test whether path exists

var oSystem =VtCreateFileSystemObject()
var bReturn =oSystem.FolderExists(sPath) || oSystem.FileExists(sPath)

oSystem =null
return bReturn
} // PathExists method

function PathGetBase(sPath) {
// Get base/root name of a file or folder

var oSystem =VtCreateFileSystemObject()
var sReturn =oSystem.GetBaseName(sPath)

oSystem = null
return sReturn
} // PathGetBase method

function PathGetCurrentDirectory() {
// Get current directory of active process

var oShell =VtCreateWScriptShell()
var sReturn =oShell.CurrentDirectory

oShell = null
return sReturn
} // PathGetCurrentDirectory method

function PathGetExtension(sPath) {
// Get extention of file or folder

var oSystem =VtCreateFileSystemObject()
var sReturn =oSystem.GetExtensionName(sPath)

oSystem = null
return sReturn
} // PathGetExtension method

function PathGetFolder(sPath) {
// Get the parent folder of a file or folder

var oSystem =VtCreateFileSystemObject()
var sReturn =oSystem.GetParentFolderName(sPath)

oSystem = null
return sReturn
} // PathGetFolder method

function PathGetInternetCacheFolder() {
// Get Windows folder for temporary Internet files

var iTemporaryInternetFiles = 32
var oShell = VtCreateShellApplication()
var oFolder = oShell.Namespace(iTemporaryInternetFiles)
var oItem = oFolder.Self
var sReturn = oItem.Path

oItem = null
oFolder = null
oShell = null
return sReturn
} // GetInternetCacheFolder method

function PathGetLong(sPath) {
// Get long name of file or folder

var oShell = VtCreateWScriptShell()
var oShortcut = oShell.CreateShortcut('temp.lnk')
oShortcut.TargetPath = sPath
var sReturn = oShortcut.TargetPath

oShortcut = null
oShell = null
return sReturn
} // PathGetLong method

function PathGetName(sPath) {
// Get the file or folder name at the end of a path

var oSystem =VtCreateFileSystemObject()
var sReturn =oSystem.GetFileName(sPath)

oSystem = null
return sReturn
} // PathGetName method

function PathGetShort(sPath) {
// Get short path (8.3 style) of a file or folder

var oSystem =VtCreateFileSystemObject()
if (FolderExists(sPath)) {
var oFolder =oSystem.GetFolder(sPath)
var sReturn =oFolder.ShortPath
}
else {
var oFile =oSystem.GetFile(sPath)
var sReturn =oFile.ShortPath
}

oFile = null
oFolder = null
oSystem = null
return sReturn
} // PathGetShort method

function PathGetSpec(sDir, sWildcards, sFlags) {
// Get a list of paths, specifying folder, wild card pattern, and sort order

var lReturn = VtCreateList()
var iWindowStyle = 0 // hidden
var bWait = true
var sCommand = '%COMSPEC% /c dir /b ' + sFlags + ' ' + '"' + sDir + '\\' + sWildcards + '"'
var sTempFile = PathGetTempFile()
var sCommand = sCommand + ' >' + sTempFile
ShellRun(sCommand, iWindowStyle, bWait)
var sReturn = StringTrim(FileToString(sTempFile))
FileDelete(sTempFile)
var aReturn = sReturn.split(vbCrLf)
for (var i = 0; i < aReturn.length; i++) {
var s = aReturn[i]
if (!StringContains(s, ':', false)) s = PathCombine(sDir, s)
lReturn.Add(s)
}
return lReturn
} // PathGetSpec method

function PathGetTempFile() {
// Get full path of a temporary file

return PathGetTempFolder() + '\\' + PathGetTempName()
} // PathGetTempFile method

function PathGetTempFolder() {
// Get Windows folder for temporary files

var iTempFolder = 2
var oSystem =VtCreateFileSystemObject()
var sReturn =oSystem.GetSpecialFolder(iTempFolder).path

oSystem = null
return sReturn
} // PathGetTempFolder method

function PathGetTempName() {
// Get Name for temporary file or folder

var oSystem =VtCreateFileSystemObject()
var sReturn = oSystem.GetTempName()

oSystem = null
return sReturn
} // PathGetTempName method

function PathGetValid(sDir, sBase, sExt, bUnique) {
var sIllegal = "&=@%*+\\|':'<>/?" + xQuote
var sViewable = "!#$%&'()*+,-./0123456789:'<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
var sPrintable = xSpace + sViewable

var sSourceDir = sDir
var sSourceBase = sBase
var sSourceExt = sExt
if (StringLength(sSourceExt) && !StringStartsWith(sSourceExt, '.', false)) sSourceExt = '.' + sSourceExt
// var sLine = sSourceBase
var sLine = sBase
var iCount = StringLength(sIllegal)
for (var i = 0; i < iCount; i++) {
var s = sIllegal.charAt(i)
// if (StringContains(sLine, s, false)) sLine = sLine.replace(s, xSpace)
if (StringContains(sLine, s, false)) sLine = StringReplace(sLine, s, xSpace, false)
}

// sLine = StringReplaceAll(sLine, '  ', xSpace)
// sLine = StringReplaceAll(sLine, '  ', '_')
sLine = VtTrim(sLine)
// sLine = RegExpReplace(sLine, ' +', '_', false)
sLine = RegExpReplace(sLine, ' +', ' ', false)

var sTargetBase = sLine
var sTargetFile = sSourceDir + '\\' + sTargetBase + sSourceExt
if (bUnique && FileExists(sTargetFile)) {
var s = '_01'
var sTargetFile = sSourceDir + '\\' + sTargetBase + s + sSourceExt
var i = 1
while (FileExists(sTargetFile) && i <= 99 ) {
if (i < 10) s = '_0' + i
else s = '_' + i

sTargetFile = sSourceDir + '\\' + sTargetBase + s + sSourceExt
i++
}
}
return sTargetFile
} // PathGetValid method

function PathSetCurrentDirectory(sDir) {
// Set current directory of active process, and return previously current directory

var oShell =VtCreateWScriptShell()
var sReturn = oShell.CurrentDirectory
oShell.CurrentDirectory = sDir

oShell = null
return sReturn
} // PathSetCurrentDirectory method

function RegExpContains(sText, sMatch, bIgnoreCase) {
/*
Get Array containing the starting index and text of the first match of a regular expression
where sText is the string to search
sMatch is the regular expression to match
bIgnoreCase indicates whether capitalization matters
*/

var lReturn = VtCreateList()
var oExp = VtCreateRegExp()
oExp.Pattern = sMatch
oExp.Ignorecase = bIgnoreCase
oExp.Multiline = false
oExp.Global = false

var oMatches = oExp.Execute(sText)
var iCount = oMatches.Count
if (iCount) {
var oMatch = oMatches.Item(0)
var iIndex = oMatch.FirstIndex
var sValue = oMatch.Value
lReturn.Add(iIndex)
lReturn.Add(sValue)
}

oMatch = null
oMatches = null
oExp = null
return lReturn
} // RegExpContains method

function RegExpContainsLast(sText, sMatch, bIgnoreCase) {
/*
Get list containing the starting index and text of the last match of a regular expression
where sText is the string to search
sMatch is the regular expression to match
bIgnoreCase indicates whether capitalization matters
*/

var lReturn = VtCreateList()
var oExp = VtCreateRegExp()
oExp.Pattern = sMatch
oExp.Ignorecase = bIgnoreCase
oExp.Multiline = false
oExp.Global = true

var oMatches = oExp.Execute(sText)
var iCount = oMatches.Count
if (iCount) {
var oMatch = oMatches.Item(iCount - 1)
var iIndex = oMatch.FirstIndex
var sValue = oMatch.Value
lReturn.Add(iIndex, sValue)
}

oMatch = null
oMatches = null
oExp = null
return lReturn
} // RegExpContainsLast method

function RegExpCount(sText, sMatch, bIgnoreCase) {
/*
Count matches of a regular expression
where sText is the string to search
sMatch is the regular expression to match
bIgnoreCase indicates whether capitalization matters
*/

var oExp = VtCreateRegExp()
oExp.Pattern = sMatch
oExp.Ignorecase = bIgnoreCase
oExp.Multiline = false
oExp.Global = true

var oMatches = oExp.Execute(sText)
var iReturn = oMatches.Count

oMatches = null
oExp = null
return iReturn
} // RegExpCount method

function RegExpExtract(sText, sMatch, bIgnoreCase) {
/*
Get list containing matches of a regular expression
where sText is the string to search
sMatch is the regular expression to match
bIgnoreCase indicates whether capitalization matters
*/

var lReturn = VtCreateList()
var oExp = VtCreateRegExp()
oExp.Pattern = sMatch
oExp.Ignorecase = bIgnoreCase
oExp.Multiline = false
oExp.Global = true

var oMatches = oExp.Execute(sText)
var iCount = oMatches.Count
for (var i = 0; i < iCount; i++) {
var oMatch = oMatches.Item(i)
lReturn.Add(oMatch.Value)
}

oMatch = null
oMatches = null
oExp = null
return lReturn
} // RegExpExtract method

function RegExpReplace(sText, sMatch, sReplace, bIgnoreCase) {
/*
Replace text matching a regular expression
where sText is the string to search
sMatch is the regular expression to match
sReplace is the replacement text
bIgnoreCase indicates whether capitalization matters
*/

var oExp = VtCreateRegExp()
oExp.Pattern = sMatch
oExp.Ignorecase = bIgnoreCase
oExp.Multiline = false
// oExp.Multiline = true
oExp.Global = true

var sReturn = oExp.replace(sText, sReplace)

oExp = null
return sReturn
} // RegExpReplace method

function RegExpTest(sText, sMatch, bIgnoreCase) {
/*
Test match of a regular expression
where sText is the string to search
sMatch is the regular expression to match
bIgnoreCase indicates whether capitalization matters
*/

var oExp = VtCreateRegExp()
oExp.Pattern = sMatch
oExp.Ignorecase = bIgnoreCase
oExp.Multiline = false
oExp.Global = true

var bReturn = oExp.Test(sText)

oExp = null
return bReturn
} // RegExpTest method

function ShellCreateShortcut(sFile, sTargetPath, sWorkingDirectory, iWindowStyle, sHotkey) {
// Create a .lnk or .url file

if (!FileDelete(sFile)) return false

var oShell = VtCreateWScriptShell()
var oShortcut = oShell.CreateShortcut(sFile)
oShortcut.TargetPath = sTargetPath
oShortcut.WorkingDirectory = sWorkingDirectory
oShortcut.WindowStyle = iWindowStyle
oShortcut.Hotkey = sHotkey
oShortcut.Save()

oShortcut = null
oShell = null
return FileExists(sFile)
} // ShellCreateShortcut method

function ShellExec(sCommand) {
// Run a console mode command and return its standard output

var oShell =VtCreateWScriptShell()
var oExec =oShell.Exec(sCommand)
while ( oExec.Status ==0) {
VtSleep(10)
}

var oOutput =oExec.StdOut
var sReturn =oOutput.ReadAll()
oExec.Terminate()

oOutput = null
oExec = null
oShell = null
return sReturn
} // ShellExec method

function ShellExecute(sFile, sParams, sFolder, sVerb, iWindowStyle) {
// Execute a command with a verb like RunAs

var bReturn = false
var oShell = VtCreateShellApplication()
try {
oShell.ShellExecute(sFile, sParams, sFolder, sVerb, iWindowStyle)
bReturn = true
}
catch (e) { }
return bReturn
} // ShellExecute method

function ShellExpandEnvironmentVariables(sText) {
// Replace environment variables with their values

var oShell =VtCreateWScriptShell()
var sReturn =oShell.ExpandEnvironmentStrings(sText)

oShell = null
return sReturn
} // ShellExpandEnvironmentVariables method

function ShellGetEnvironmentVariable(sVariable) {
// Get the value of an environment variable

var oShell =VtCreateWScriptShell()
var oEnv =oShell.Environment
var sReturn =oEnv.Item(sVariable)

oEnv = null
oShell = null
return sReturn
} // ShellGetEnvironmentVariable method

function ShellGetShortcutTargetPath(sFile) {
// Get the target path of a shortcut file

var oShell = VtCreateWScriptShell()
var oShortcut = oShell.CreateShortcut(sFile)
var sReturn = oShortcut.TargetPath
oShortcut = null
oShell = null
return sReturn
} // ShellGetShortcutTargetPath method

function ShellGetSpecialFolder(vFolder) {
// Get a special Windows folder

var oShell = VtCreateShellApplication()
var oNamespace = oShell.Namespace(vFolder)
var oFolder = oNamespace.Self
var sReturn = oFolder.Path
oFolder = null
oNamespace = null
oShell = null
return sReturn
} // ShellGetSpecialFolder method

function ShellInvokeVerb(sPath, sVerb) {
// Invoke a verb on a file or folder

var sFolder = PathGetFolder(sPath)
var sName = PathGetName(sPath)
var oShell = VtCreateShellApplication()
var oFolder = oShell.Namespace(sFolder)
var oName = oFolder.ParseName(sName)
var bReturn = oName.InvokeVerb(sVerb)

oName = null
oFolder = null
oShell = null
return bReturn
} // ShellInvokeVerb method

function ShellOpen(sPath) {
// Open a file or folder with the default program associated with its type

return ShellRun(StringQuote(sPath), 1, false)
} // ShellOpen method

function ShellOpenWith(sExe, sParam) {
// Open a program with a file

return ShellRun(StringQuote(sExe) + ' ' + StringQuote(sParam), 1, false)
} // ShellRunWith method

function ShellRun(sFile, iStyle, bWait) {
/*
Launch a program or file, indicating its window style && whether to wait before returning
window styles:
0 Hides the window && activates another window
1 Activates && displays a window. If the window is minimized || maximized, the
system restores it to its original size && position. This flag should be used
when specifying an application for the first time
2 Activates the window && displays it minimized
3 Activates the window && displays it maximized
4 Displays a window in its most recent size && position. The active window
remains active
5 Activates the window && displays it in its current size && position
6 Minimizes the specified window && activates the next top-level window in the Z
order
7 Displays the window as a minimized window. The active window remains active
8 Displays the window in its current state. The active window remains active
9 Activates && displays the window. If it is minimized || maximized, the system
restores it to its original size && position. An application should specify
this flag when restoring a minimized window
10 Sets the show state based on the state of the program that started the
application
*/

var oShell =VtCreateWScriptShell()
var iReturn = -2
try {
iReturn =oShell.Run(sFile, iStyle, bWait)
}
catch (e) { }

oShell = null
return iReturn
} // ShellRun method

function ShellRunCommandPrompt(sDir) {
// Open a command prompt in the directory specified

return ShellRun('%COMSPEC% /k cd ' + StringQuote(sDir), 1, false)
} // ShellRunCommandPrompt method

function ShellRunExplorerWindow(sDir) {
// Open Windows Explorer in the directory specified

return ShellOpen(sDir)
} // ShellRunExplorerWindow method

function ShellWait(sPath) {
// Run a program and wait for it to return

return ShellRun(StringQuote(sPath), 0, true)
} // ShellWait method

function StringAppendToFile(sText, sFile, sDivider) {
// Append string to File, omitting divider if the first one

if (FileExists(sFile)) sText = FileToString(sFile) + sDivider + sText
StringToFile(sText, sFile)
return FileExists(sFile)
} // StringAppendToFile method

function StringChomp(sText) {
// Chop \n for both ends of a string

var sReturn = sText
while (sReturn.length) {
if (!StringStartsWith(sReturn, '\n', false)) break
sReturn = StringChopLeft(sReturn, 1)
}
while (sReturn.length) {
if (!StringEndsWith(sReturn, '\n', false)) break
sReturn = StringChopRight(sReturn, 1)
}
return sReturn
} // StringChomp method

function StringChopLeft(sText, iCount) {
// Remove iCount characters from left of sText

var iIndex = JsMin(iCount, sText.length)
return sText.slice(iIndex)
// return sText.Substring(iIndex)
} // StringChopLeft method

function StringChopRight(sText, iCount) {
// Remove iCount characters from Right of sText

var iIndex = JsMin(iCount, sText.length) * -1
return sText.slice(0, iIndex)
} // StringChopRight method

function StringContains(sText, sMatch, bIgnoreCase) {
// Test if a string is contained in another

if (bIgnoreCase) {
var sText = sText.toLowerCase()
var sMatch = sMatch.toLowerCase()
}

return sText.indexOf(sMatch) >= 0
} // StringContains method

function StringConvertToMacLineBreak(sText) {
// Convert to Macintosh line break, \r

var sReturn = sText
sReturn = StringReplace(sReturn, vbCrLf, vbCr, false)
sReturn = StringReplace(sReturn, vbLf, vbCr, false)
return sReturn
}

function StringConvertToUnixLineBreak(sText) {
// Convert to Unix line break, \n

var sReturn = sText
sReturn = StringReplace(sReturn, vbCrLf, vbLf, false)
sReturn = StringReplace(sReturn, vbCr, vbLf, false)
return sReturn
}

function StringConvertToWinLineBreak(sText) {
// Convert to standard Windows line break, \r\n

var sReturn = sText
sReturn = StringReplace(sReturn, vbCrLf, vbLf, false)
sReturn = StringReplace(sReturn, vbCr, vbLf, false)
sReturn = StringReplace(sReturn, vbLf, vbCrLf, false)
return sReturn
}

function StringCount(sText, sMatch) {
// Count occurrences of a string within another string

var iLength = sText.length
var s = sText.replace(sMatch, xMute)
var iDelta = iLength - s.length
var iReturn = iDelta / sMatch.length
return iReturn
} // StringCount method

function StringEndsWith(sText, sSuffix, bIgnoreCase) {
// Test whether first string ends with second one

if (bIgnoreCase) {
var sText = sText.toLowerCase()
var sSuffix = sSuffix.toLowerCase()
}

var iText = sText.length
var iSuffix = sSuffix.length
if (iSuffix > iText) return false
return sText.slice(-iSuffix) == sSuffix
} // StringEndsWith method

function StringEqual(s1, s2) {
// Test if two strings are exactly equal

return s1 == s2
} // StringEqual method

function StringEquiv(s1, s2) {
// Test whether two strings are the same except for capitalization

return s1.toLowerCase() == s2.toLowerCase()
} // StringEquiv method

function StringGetASCII(sText) {
// Get space delimited ASCII codes for characters in string

var sReturn = xMute
var iCount = sText.length
for (var i = 0; i < iCount; i++ ) {
var s = sText.charAt(i)
if (sReturn.length) sReturn += xSpace
sReturn += s.charCode(0)
}
return sReturn
} // StringGetASCII method

function StringLeft(sText, iCount) {
// Return leftmost characters of a string

return sText.slice(0, iCount)
} // StringLeft method

function StringLength(sText) {
// Return length of a string

return sText.length
} // StringLength method

function StringLower(sText) {
// Convert string to lower case

return sText.toLowerCase()
} // StringLower method

function StringPlural(sItem, iCount) {
// Return singular or plural form of a string, depending on whether count equals one

var sReturn = JsString(iCount) + ' ' + sItem
if (iCount != 1) sReturn += 's'
return sReturn
} // StringCount method

function StringQuote(sText) {
// Quote a string

return '"' + sText + '"'
} // StringQuote method

function StringReplaceAll(sText, sMatch, sReplace, bIgnoreCase) {
// Replace all occurrences of a string within another

if (StringContains(sReplace, sMatch, bIgnoreCase)) return StringReplace(sText, sMatch, sReplace, bIgnoreCase)

var sReturn = sText
while ( StringContains(sReturn, sMatch, bIgnoreCase)) {
sReturn = StringReplace(sReturn, sMatch, sReplace, bIgnoreCase)
}
return sReturn
} // StringReplaceAll method

function StringRight(sText, iCount) {
// Return rightmost characters of a string

var iLength = sText.length
var iPosition = iLength - iCount
return sText.slice(iPosition)
} // StringRight method

function StringSlice(sText, iStart, iEnd) {
return sText.slice(iStart, iEnd)
} // StringSlice method

function StringStartsWith(sText, sPrefix, bIgnoreCase) {
// Test whether first string starts with second one

if (bIgnoreCase) {
var sText = sText.toLowerCase()
var sPrefix = sPrefix.toLowerCase()
}

var iText = sText.length
var iPrefix = sPrefix.length
if (iPrefix > iText) return false

return sText.slice(0, iPrefix) == sPrefix
} // StringStartsWith method

function StringToFile(sText, sFile) {
// Saves string to text file, replacing if it exists

if (!FileDelete(sFile)) return false

var bReplace = true
var bUnicode = false
// bUnicode = true
var oSystem =VtCreateFileSystemObject()
var oFile =oSystem.CreateTextFile(sFile, bReplace, bUnicode)
try {
oFile.Write(sText)
oFile.Close()
}
catch (e) { }

oFile = null
oSystem = null
return FileExists(sFile)
} // StringToFile method

function StringToList(sText, sDelimiter) {
// Convert string with specified delimiter to list

var lReturn = VtCreateList()
var aParts = sText.split(sDelimiter)
for (var i = 0; i < aParts.length; i++) {
var sPart = aParts[i]
lReturn.Add(sPart)
}
return lReturn
} // StringToList method

function StringTrim(sText) {
// Trim white space from both ends of a string

// return sText.replace(/(^\s*)|(\s*$)/g/, '')
var sText = RegExpReplace(sText, '^\\s+', xMute, false)
sText = RegExpReplace(sText, '\\s+$', xMute, false)
return sText
} // StringTrim method

function StringTrimLeft(sText) {
// Trim white space from left end of a string

return RegExpReplace(sText, '^\\s+', xMute, false)
} // StringTrimLeft method

function StringTrimRight(sText) {
// Trim white space from right end of a string

return RegExpReplace(sText, '\\s+$', xMute, false)
} // StringTrimRight method

function StringUnquote(sText) {
// Unquote a string

var sReturn = sText
while ( StringLeft(sReturn, 1) == '"') {
sReturn = StringChopLeft(sReturn, 1)
}

while (StringRight(sReturn, 1) == '"') {
sReturn = StringChopRight(sReturn, 1)
}
return sReturn
} // StringUnquote method

function StringUpper(sText) {
// Convert string to upper case

return sText.toUpperCase()
} // StringUpper method

function StringWrap(sText, iMaxLine) {
var aLines, aWords
var i, j
var sReturn, sLines, sLine, sWords, sWord

aLines = sText.split(vbCrLf)
sReturn = xMute
var iCount = aLines.length
for (var i = 0; i < iCount; i++) {
sLine = aLines[i]
if (sLine.length > iMaxLine) {
aWords = sLine.split(' ')
sLine = xMute
for (var j = 0; j < aWords.length; j++) {
sWord = aWords(j)
if (sLine.length + sWord.length > iMaxLine) {
sReturn += StringTrim(sLine) + vbCrLf
sLine = sWord + ' '
}
else {
sLine = sLine + sWord + ' '
}
}
}
else {
sReturn += StringTrimRight(sLine) + vbCrLf
}
}
return sReturn
} // StringWrap method

function UrlCreate(sProtocol, sHost, sPath, sQuery) {
// Create a URL from components

var sReturn = xMute
if (!sProtocol) sProtocol = 'http'
sReturn += sProtocol + '://'
if (sHost) sReturn += sHost
if (sPath) sReturn += '/' + sPath
if (sQuery) sReturn += '?' + sQuery
return sReturn
} // UrlCreate method

function UrlGetBaseDomain(sUrl) {
// Get base domain of a URL

var sReturn = xMute
var s = UrlGetHost(sUrl)
var a = s.split('.')
var iLength = a.length
if (iLength >= 3 && a[iLength -1].length == 2) s = a[iLength -3] + '.' + a[iLength - 2] + '.' + a[iLength - 1]
else if (iLength >= 2) s = a[iLength -2] + '.' + a[iLength - 1]
if (s.indexOf('.') >= 0) sReturn = s
return sReturn
} // UrlGetBaseDomain method

function UrlGetExtension(sUrl) {
// Get extension of a URL

var sReturn = UrlGetFileName(sUrl)
if (sReturn) sReturn = PathGetExtension(sReturn)
return sReturn
} // UrlGetExtension method

function UrlGetFileName(sUrl) {
// Get file of a URL

var sReturn = UrlGetPath(sUrl)
if (sReturn) sReturn = PathGetName(sReturn)
return sReturn
} // UrlGetFileName method

function UrlGetFolder(sUrl) {
// Get folder of a URL

var sReturn = UrlGetPath(sUrl)
// if (sReturn) sReturn = PathGetFolder(sReturn)
if (sReturn && !StringEndsWith(sReturn, '/', false)) sReturn = PathGetFolder(sReturn)
return sReturn
} // UrlGetFolder method

function UrlGetFragment(sUrl) {
// Get fragment of a URL

var sReturn = xMute
var i = sUrl.indexOf('#')
if (i >= 0) sReturn = sUrl.slice(i + 1)
return sReturn
} // UrlGetFragment method

function UrlGetFullFolder(sUrl) {
// Get full url tup to and including folder

// ShellOpen('SayLine.exe', 'full folder')
var sPrepath = UrlGetPrePath(sUrl)
// var sPrepath = ''
// DialogShow('prepath', sPrepath)
var sFolder = UrlGetFolder(sUrl)
// DialogShow('folder', sFolder)
var sReturn = sPrepath + sFolder
return sReturn
} // UrlGetFullFolder method

function UrlGetHost(sUrl) {
// Get subdomain and domain of a URL

var sReturn = sUrl
var i = sReturn.indexOf('://')
if (i >= 0) sReturn = sReturn.slice(i + 3)
// if (StringStartsWith(sReturn, 'www.', true)) sReturn = StringChopLeft(sReturn, 4)
i = sReturn.indexOf('/')
if (i >= 0) sReturn = sReturn.slice(0, i)
if (sReturn.indexOf('.') == -1) sReturn = xMute
return sReturn
} // UrlGetHost method

function UrlGetPath(sUrl) {
// Get path of a URL

var sReturn = UrlGetPathPlus(sUrl)
var sFragment = UrlGetFragment(sReturn)
if (sFragment) sReturn = StringChopRight(sReturn, sFragment.length + 1)
var sQuery = UrlGetQuery(sReturn)
if (sQuery) sReturn = StringChopRight(sReturn, sQuery.length + 1)
return sReturn
} // UrlGetPath method

function UrlGetPathPlus(sUrl) {
// Get path and fragment or query of a URL

var sReturn = xMute
var s = sUrl
var sProtocol = UrlGetProtocol(s)
if (sProtocol) s = StringChopLeft(s, sProtocol.length + 3)
var sHost = UrlGetHost(s)
if (sHost) s = StringChopLeft(s, sHost.length + 1)
sReturn = s
return sReturn
} // UrlGetPathPlus method

function UrlGetPrePath(sUrl) {
// Get part of URL before path

// ShellOpenWith('SayLine.exe', 'prepath')
var sReturn = xMute
sReturn = sUrl
var sPathPlus = UrlGetPathPlus(sUrl)
// ShellOpenWith('SayLine.exe', 'PathPlus: ' + sPathPlus)
if (sPathPlus) sReturn = StringChopRight(sUrl, sPathPlus.length)
// ShellOpenWith('SayLine.exe', 'Prepath: ' + sReturn)
return sReturn
} // UrlGetPrePath method

function UrlGetProtocol(sUrl) {
// Get protocol of URL

var sReturn = xMute
var i = sUrl.indexOf('://')
if (i >= 0) sReturn = sUrl.slice(0, i)
return sReturn
} // UrlGetProtocol method

function UrlGetQuery(sUrl) {
// Get query of URL

var sReturn = xMute
var i = sUrl.indexOf('?')
if (i >= 0) sReturn = sUrl.slice(i + 1)
return sReturn
} // UrlGetQuery method

function UrlGetSubdomain(sUrl) {
// Get subdomain of a URL

var sReturn = xMute
var s = UrlGetHost(sUrl)
var a = s.split('.')
for (var i = 0; i < a.length - 2; i++) {
if (i) sReturn += '.'
sReturn += a[i]
}
return sReturn
} // UrlGetSubdomain method

function UrlNormalize(sUrl, sBase) {
// Normalize a URL for comparison

// ShellOpenWith('SayLine.exe', 'normalize')
var sReturn = sUrl
if (!sBase) var sBase = xMute
var sBase = UrlGetFullFolder(sBase)
// DialogShow('base', sBase)

// return sReturn
if (StringEqual(StringLeft(sReturn, 2), '//')) sReturn = 'http:' + sReturn
// DialogShow(sReturn, sBase)
var sProtocol = UrlGetProtocol(sReturn)
// DialogShow('protocol', sProtocol)
// If (sUrl.toLowerCase().indexOf('aboutus') >= 0) DialogShow('base', sBase)
if (!sProtocol) {
// DialogShow(StringLeft(sReturn, 2), '')
var iIndex = sReturn.indexOf(':')
if (iIndex >= 0) sReturn = StringChopLeft(sReturn, iIndex + 1)
}

if (!sProtocol && sBase) {
if (StringStartsWith(sReturn, '/', false)) sBase = UrlGetPrePath(sBase)
if (StringEndsWith(sBase, '/', false) && StringStartsWith(sReturn, '/', false)) {
sReturn = StringChopRight(sBase, 1) + sReturn
}
else if (!StringEndsWith(sBase, '/', false) && !StringStartsWith(sReturn, '/', false)) {
sReturn = sBase + '/' + sReturn
}
else {
sReturn = sBase + sReturn
}
}

sProtocol = UrlGetProtocol(sReturn)
if (!sProtocol) sReturn = 'http://' + sReturn

var sPrePath = UrlGetPrePath(sReturn)
if (sReturn == sPrePath && !StringEndsWith(sPrePath, '/', false)) sReturn += '/'

var sFragment = UrlGetFragment(sReturn)
if (sFragment) sReturn = StringChopRight(sReturn, sFragment.length + 1)
return sReturn
} // UrlNormalize method

function VtArrayToJs(a) {
// Convert variant array to JScript

return (new VBArray(a)).toArray()
} // VtArrayToJs method

function VtArrayToList(a) {
// Convert variant array to list

var aJs = VtArrayToJs(a)
var lReturn = VtCreateList()
for (var i = 0; i < aJs.length; i++) lReturn.Add(aJs[i])
return lReturn
} // VtArrayToList method

function VtCopyDictionary(dItems) {
// Copy a dictionary

var dReturn = VtCreateDictionary()
var aKeys = VtDictionaryKeysToJs(dItems)
for (var i = 0; i < aKeys.length; i++) {
var sKey = aKeys[i]
dReturn(sKey) = dItems(sKey)
}
return dReturn
} // VtCopyDictionary method

function VtCopyList(lItems) {
// Copy a list

var lReturn = VtCreateList()
for (var i = 0; i < lItems.Count; i++) {
var sItem = lItems(i)
lReturn.Add(sItem)
}
return lReturn
} // VtCopyList method

function VtCreateDictionary() {
// Return a variant dictionary

return new ActiveXObject('Scripting.Dictionary')
} // VtCreateDictionary method

function VtCreateFileSystemObject() {
// Return a file system object

return new ActiveXObject('Scripting.FileSystemObject')
} // VtCreateFileSystemObject

function VtCreateHtmlFile() {
// Create a variant HTMLFile object

// return new ActiveXObject('HTMLFile')
return new ActiveXObject('HTMLFile')
} // CreateHtmlFile method

function VtCreateInternetExplorerApplication() {
// Return an Internet Explorer object

return new ActiveXObject('InternetExplorer.Application')
} // VtCreateInternetExplorerApplication method

function VtCreateList() {
// Create a variant list object

return new ActiveXObject('System.Collections.ArrayList')
} // VtCreateList method

function VtCreateRecordSet() {
// Create a variant record set object

var oRs = new ActiveXObject('ADODB.RecordSet')
oRs.CursorLocation = adUseClient
return oRs
} // VtCreateRecordSet method

function VtCreateRegExp() {
// Return a scripting RegExp object

return new ActiveXObject('VBScript.RegExp')
} // VtCreateRegExp method

function VtCreateShellApplication() {
// Return a Shell.Application object

return new ActiveXObject('Shell.Application')
} // VtCreateShellApplication method

function VtCreateStream() {
// Return an ADODB.Stream object

var oStream = new ActiveXObject('ADODB.Stream')
oStream.Type = adTypeBinary
oStream.Open()
return oStream
} // VtCreateStream method

function VtCreateVBScriptControl() {
// Return MSScriptControl.ScriptControl object

var oScript = new ActiveXObject('MSScriptControl.ScriptControl')
oScript.Language = 'VBScript'
return oScript
} // VtCreateVBScriptControl method

function VtCreateWebRequest() {
// Create web request object

// Does not work reliably with GET request
// return new ActiveXObject('MSXML2.XMLHTTP')
// return new ActiveXObject('MSXML2.XMLHTTP.6.0')

return new ActiveXObject('MSXML2.ServerXMLHTTP')

// Does not work reliably with POST request
var oRequest = new ActiveXObject('WinHttp.WinHttpRequest.5.1')
var WinHttpRequestOption_SslErrorIgnoreFlags  = 4
oRequest.Option(WinHttpRequestOption_SslErrorIgnoreFlags) = 0x3300 // ignore all server certificate errors
var WinHttpRequestOption_EnableHttpsToHttpRedirects = 12
oRequest.Option(WinHttpRequestOption_EnableHttpsToHttpRedirects  ) = true
return oRequest
} // VtCreateWebRequest method

function VtCreateWinHttpRequest() {
// Create WinHttp request object

var oRequest = new ActiveXObject('WinHttp.WinHttpRequest.5.1')
var WinHttpRequestOption_SslErrorIgnoreFlags  = 4
oRequest.Option(WinHttpRequestOption_SslErrorIgnoreFlags) = 0x3300 // ignore all server certificate errors
var WinHttpRequestOption_EnableHttpsToHttpRedirects = 12
oRequest.Option(WinHttpRequestOption_EnableHttpsToHttpRedirects  ) = true
return oRequest
} // VtCreateWinHttpRequest method

function VtCreateWScriptShell() {
// Return WScript.Shell object

return new ActiveXObject('Wscript.Shell')
} // VtCreateWScriptShell method

function VtCreateXmlDocument() {
// Return an XML document

var oDoc = new ActiveXObject('MSXML2.DOMDocument')
oDoc.async = false
oDoc.setProperty('SelectionLanguage', 'XPath')
// Not necessary, since the following line is the default
// Set oNode = oDoc.createProcessingInstruction ('xml', 'version=''1.0'' encoding=''UTF-8''')
// o Doc.appendChild(oNode)
return oDoc
} // VtCreateXmlDocument method

function VtDateToJs(dt) {
// Convert a variant date to JScript

return Date.parse(dt)
} // VtDateToJs method

function VtDictionaryKeysToJs(d) {
// Convert variant array of dictionary keys to JScript array

var a = VtArrayToJs(d.Keys())
return a
} // VtDictionaryKeysToJs method

function VtDictionaryKeysToList(d) {
// Convert variant array of dictionary keys to list

var l = VtArrayToList(d.Keys())
return l
} // VtDictionaryKeysToList method

function VtDictionaryToJs(d) {
// Convert a variant dictionary to JScript

var aKeys = d.Keys()
var a = VtArrayToJs(aKeys)
var dReturn = {}
for (var i = 0; i < a.length; i++) {
var sKey = a[i]
dReturn[sKey] = d.Item(sKey)
}
return dReturn
} // VtDictionaryToJs method

function VtDictionaryToXml(dItems, sFile) {
// Save dictionary to XML file

var d = VtDictionaryToJs(dItems)
for (var sKey in d) {
var sValue = d[sKey]
XmlSetValue(sFile, sKey, sValue)
}
} // VtDictionaryToXml method

function VtGetWMIObject() {
// Get WMI object

return GetObject('winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv')
} // VtGetWMIObject method

function VtInitDictionary(vValue) {
// Create a variant dictionary and initialize it with a single key/value pair

var dReturn = VtCreateDictionary()
dReturn.Add('v', vValue)
return dReturn
} // VtInitDictionary method

function VtInitXmlDocument(sXml) {
// Create and initialize an Xml document with a string of XML

var oDoc = VtCreateXmlDocument()
oDoc.loadXML(sXml)
return oDoc
} // VtInitXmlDocument method

function VtListFilterByExtension(lPaths, lExtensions) {
// Get a subset from a list of paths that match an extension

var lReturn = VtCreateList()
var sExtensions = xMute
// DialogShow(lPaths.Count.toString(), lExtensions.Count.toString())
for (var i = 0; i < lPaths.Count; i++) {
// ShellOpenWith('c:\\mctwit\\sayline.exe', i.toString())
var sPath = lPaths(i)
// sPath = StringTrim(sPath)
var sExtension = PathGetExtension(sPath)
// sExtension = StringRight(sPath, 3)
// if (!i) DialogShow(sExtension, sExtension.length.toString())
if (StringStartsWith(sPath, '.', false)) sExtension = StringChopLeft(sExtension, 1)
sExtension = sExtension.toLowerCase()
if (lExtensions.Contains(sExtension)) lReturn.Add(sPath)
sExtensions += sPath + ' = ' + sExtension + '\r\n'
// sExtension = StringTrim(sExtension)
// if (!i) sExtensions = sExtension
// StringToFile(sExtensions, 'c:\\temp\\temp.txt')
}
// ShellOpenWith('c:\\mctwit\\sayline.exe', lReturn.Count.toString())
// StringToFile(sExtensions, 'c:\\temp\\temp.txt')
return lReturn
} // VtFilterByExtension method

function VtListFilterByRegExp(lItems, sMatch, bIgnoreCase) {
// Return list of matches of a regular expression

var lReturn = VtCreateList()
for (var i = 0; i < lItems.Count; i++) {
var sItem = lItems(i)
if (RegExpTest(sItem, sMatch, bIgnoreCase)) lReturn.Add(sItem)
}
return lReturn
} // VtListFilterByRegExp method

function VtListFilterByWildcard(lItems, sMatch) {
// Return list of matches of a wildcard filter expression

var lReturn = VtCreateList()
if (!lItems) return lReturn

var oRs = VtCreateRecordSet()
var oFields = oRs.Fields
oFields.Append('Item', adVarWChar, xMaxPath)
oRs.Open()

for (var i = 0; i < lItems.Count; i++) {
var sItem = lItems(i)
oRs.AddNew('Item', sItem)
}
oRs.Update()

oRs.Filter = "Item Like '" + sMatch + "'"
var oField = oFields('Item')
if (!oRs.BOF) oRs.MoveFirst()
while (!oRs.EOF) {
var sValue = oField.Value
lReturn.Add(sValue)

oRs.MoveNext()
}
oRs.Close()

oField = null
oFields = null
oRs = null
return lReturn
} // VtListFilterByWildcard method

function VtListGetExtensions(lPaths) {
// Get a list of extensions from a list of paths, converting to lower case, removing duplicates, and sorting

var lReturn = VtCreateList()
for (var i = 0; i < lPaths.Count; i++) {
var sPath = lPaths(i)
// if (StringContains(sPath, '://', false)) sPath = WebUrlDownloadFileName(sPath, 'C:\\temp', false)
sPath = PathGetName(sPath)
var sExtension = PathGetExtension(sPath)
if (StringStartsWith(sExtension, '.', false)) sExtension = StringChopLeft(sExtension, 1)
sExtension = RegExpReplace(sExtension, '[^0-9a-zA-Z]', '', true)
if (sExtension.length > 5) sExtension = ''
// if (!sExtension) continue
if (!sExtension) sExtension = "htm"
sExtension = sExtension.toLowerCase()
if (lReturn.Contains(sExtension)) continue
lReturn.Add(sExtension)
}
lReturn.Sort()
return lReturn
} // VtListGetExtensions method

function VtListToJs(l) {
// Convert variant list to JScript array

var aReturn = []
for (var i = 0; i < l.Count; i++) aReturn[i] = l.Item(i)
return aReturn
} // VtListToJs method

function VtListToString(lItems, sDelimiter) {
// Convert a list to a string with a specified delimiter

var sReturn = xMute
for (var i = 0; i < lItems.Count; i++) {
var oItem = lItems(i)
var sItem = JsString(oItem)
if (i > 0) sReturn += sDelimiter
sReturn += sItem
}
return sReturn
} // VtListToStringMethod

function VtStreamToFile(aBytes, sFile) {
// Save a variant byte array to a binary file

try {
var oStream = VtCreateStream()
oStream.Write(aBytes)
oStream.SaveToFile(sFile, adSaveCreateOverWrite)
oStream.Close()
}
catch (e) {
DialogShow('Error', e.description)
}
oStream = null
return FileExists(sFile)
} // VtStreamToFile method

function WebFetch(dParams) {
// Fetch files from web according to specifications in dictionary of parameters

/*
SearchScope values:
Path, with same directory and subdomain
Subdomain, with any directory
Domain, with any directory or subdomain
Other, restricted by filters or additional limits
*/

if (!dParams.Exists('LinkSegment')) dParams('LinkSegment') = 1
if (!dParams.Exists('TimeLimit')) dParams('TimeLimit') = 0
if (!dParams.Exists('TimeStart')) dParams('TimeStart') = (new Date()).getTime()
if (!dParams.Exists('MaximumSize')) dParams('MaximumSize') = 0
if (!dParams.Exists('TotalSize')) dParams('TotalSize') = 0
if (!dParams.Exists('EventLog')) dParams('EventLog') = xMute
if (!dParams.Exists('CrawlUrls')) dParams('CrawlUrls') = VtCreateList()
if (!dParams.Exists('FetchUrls')) dParams('FetchUrls') = VtCreateList()

var iNow = (new Date()).getTime()
var iDelta = iNow - dParams('TimeStart')

if ((dParams('TimeLimit') > 0) && (iDelta > dParams('TimeLimit'))) {
sReturn += 'Time limit of ' + StringCount('minute', iDelta / Math.pow(60, 2)) + ' exceeded' + '\n'
return dParams
}

if ((dParams('MaximumSize') > 0) && (dParams('TotalSize') > dParams('MaximumSize'))) {
sReturn += 'Maximum size of ' + StringCount('megabyte', d('MaximumSize') / Math.pow(1024, 2)) + ' exceeded' + '\n'
return dParams
}

var sReturn = 'Parameters:' + '\n'
var d = VtDictionaryToJs(dParams)
for (var sKey in d)  sReturn += sKey +'=' + d[sKey] + '\n'
sReturn += '\n'

var sProjectFolder = d['ProjectFolder']
var bIncludeSubfolders = d['IncludeSubfolders']
var bUniquePath = true
if (bIncludeSubfolders) bUniquePath = false
var sSearchScope = d['SearchScope']
var bQueryOnly = d['QueryOnly']

var aBodyFilters = JsSplitLines(d['BodyFilters'])
var aIncludeBodyFilters = []
var aExcludeBodyFilters = []
for (var iBodyFilter = 0; iBodyFilter < aBodyFilters.length; iBodyFilter++) {
var sBodyFilter = aBodyFilters[iBodyFilter]
if (!sBodyFilter) continue
if (StringStartsWith(sBodyFilter, '-', false)) {
sBodyFilter = StringChopLeft(sBodyFilter, 1)
aExcludeBodyFilters.push(sBodyFilter)
}
else {
if (StringStartsWith(sBodyFilter, '+', false)) sBodyFilter = StringChopLeft(sBodyFilter, 1)
aIncludeBodyFilters.push(sBodyFilter)
}
} // create BodyFilter arrays

var aUrlFilters = JsSplitLines(d['UrlFilters'])
var aIncludeUrlFilters = []
var aExcludeUrlFilters = []
for (var iUrlFilter = 0; iUrlFilter < aUrlFilters.length; iUrlFilter++) {
var sUrlFilter = aUrlFilters[iUrlFilter]
if (!sUrlFilter) continue
if (StringStartsWith(sUrlFilter, '-', false)) {
sUrlFilter = StringChopLeft(sUrlFilter, 1)
aExcludeUrlFilters.push(sUrlFilter)
}
else {
if (StringStartsWith(sUrlFilter, '+', false)) sUrlFilter = StringChopLeft(sUrlFilter, 1)
aIncludeUrlFilters.push(sUrlFilter)
}
} // create URL filter arrays

var aWebSource = JsSplitLines(d['WebSource'])
sReturn += 'Fetching' +'\n'
for (var iWebSource = 0; iWebSource < aWebSource.length; iWebSource++) {
var sWebSource = aWebSource[iWebSource]
if (!sWebSource) continue
if (dParams('FetchUrls').Contains(sWebSource)) continue
sReturn += 'Web source ' + sWebSource + '\n'
var bIncludeWebSource = true
for (var iExcludeUrlFilter = 0; iExcludeUrlFilter < aExcludeUrlFilters.length; iExcludeUrlFilter++) {
var sExcludeUrlFilter = aExcludeUrlFilters[iExcludeUrlFilter]
if (!sExcludeUrlFilter) continue
if (RegExpTest(sWebSource, sExcludeUrlFilter, true)) {
bIncludeWebSource = false
sReturn += 'No fetch from exclude URL filter ' + sExcludeUrlFilter + '\n'
break
}
} // Test exclude URL filters
if (!bIncludeWebSource) continue

if (aIncludeUrlFilters.length) bIncludeWebSource = false
for (var iIncludeUrlFilter = 0; iIncludeUrlFilter < aIncludeUrlFilters.length; iIncludeUrlFilter++) {
var sIncludeUrlFilter = aIncludeUrlFilters[iIncludeUrlFilter]
if (!sIncludeUrlFilter) continue
if (RegExpTest(sWebSource, sIncludeUrlFilter, true)) {
bIncludeWebSource = true
sReturn += 'Fetch from include URL filter ' + sIncludeUrlFilter + '\n'
break
}
} // Test include URL filters
if (!bIncludeWebSource) continue

var sFolder = UrlGetFolder(sWebSource)
if (bIncludeSubfolders && sFolder) sFolder = PathCombine(sProjectFolder, sFolder)
// var sFile = WebUrlDownloadFileName(sWebSource, sFolder, bUniquePath)
var sFile = WebUrlDownloadFileName(sWebSource)
dParams('FetchUrls').Add(sWebSource)
if (bQueryOnly) continue
else if (WebUrlToFile(sWebSource, sFile)) {
sReturn += 'Download ' + sFile + '\n'
var iSize = FileGetSize(sFile)
d('TotalSize') += iSize
}
else sReturn += 'Cannot download ' + sFile + '\n'
} // Fetch web sources
if (d['LinkSegment'] >= d['LinkDistance']) return sReturn

sReturn += 'Crawling' + '\n'
for (var iWebSource = 0; iWebSource < aWebSource.length; iWebSource++) {
var sWebSource = aWebSource[iWebSource]
if (!sWebSource) continue
if (dParams('CrawlUrls').Contains(sWebSource)) continue
if (!WebUrlIsHtml(sWebSource)) continue
dParams('CrawlUrls').Add(sWebSource)
sReturn += 'HTML ' + sWebSource + '\n'
var sBody = HtmlGetText(sWebSource, false)

var bIncludeWebSource = true
for (var iExcludeBodyFilter = 0; iExcludeBodyFilter < aExcludeBodyFilters.length; iExcludeBodyFilter++) {
var sExcludeBodyFilter = aExcludeBodyFilters[iExcludeBodyFilter]
if (!sExcludeBodyFilter) continue
if (RegExpTest(sBody, sExcludeBodyFilter, true)) {
bIncludeWebSource = false
sReturn += 'No crawl from exclude body filter ' + sExcludeBodyFilter + '\n'
break
}
} // Test exclude body filters
if (!bIncludeWebSource) continue

if (aIncludeBodyFilters.length) bIncludeWebSource = false
for (var iIncludeBodyFilter = 0; iIncludeBodyFilter < aIncludeBodyFilters.length; iIncludeBodyFilter++) {
var sIncludeBodyFilter = aIncludeBodyFilters[iIncludeBodyFilter]
if (!sIncludeBodyFilter) continue
if (RegExpTest(sBody, sIncludeBodyFilter, true)) {
bIncludeWebSource = true
sReturn += 'Crawl from include body filter ' + sIncludeBodyFilter + '\n'
break
}
} // Test include body filters
if (!bIncludeWebSource) continue

var lLinkUrls = HtmlGetUrls(sWebSource)
for (var iLinkUrl = 0; iLinkUrl < lLinkUrls.Count; iLinkUrl++) {
var sLinkUrl = lLinkUrls(iLinkUrl)
sReturn += 'Link URL ' + sLinkUrl + '\n'
if (StringEquiv(sSearchScope, 'Path') && !(StringEquiv(UrlGetHost(sWebSource), UrlGetHost(sLinkUrl)) && StringEquiv(UrlGetFolder(sWebSource), UrlGetFolder(sLinkUrl)))) {
sReturn += 'No crawl from search scope ' + sSearchScope + '\n'
continue
}
else if (StringEquiv(sSearchScope, 'Subdomain') && !StringEquiv(UrlGetHost(sWebSource), UrlGetHost(sLinkUrl))) {
sReturn += 'No crawl from search scope ' + sSearchScope + '\n'
continue
}
else if (StringEquiv(sSearchScope, 'Domain') && !StringEquiv(UrlGetBaseDomain(sWebSource) , UrlGetBaseDomain(sLinkUrl))) {
sReturn += 'No crawl from search scope ' + sSearchScope + '\n'
continue
}

var dCopy = VtCopyDictionary(dParams)
dCopy('WebSource') = sLinkUrl
dCopy('LinkSegment')++
var dReturn = WebFetch(dCopy)
if (JsIsObject(dReturn)) {
sReturn += dReturn('EventLog') + '\n'
dParams('TotalSize') = dReturn('TotalSize')
dParams('CrawlUrls') = dReturn('CrawlUrls')
dParams('FetchUrls') = dReturn('FetchUrls')
sReturn += '\n'
}
} // Iterate LinkURLs
} // Iterate web sources
dParams('EventLog') = sReturn
return dParams
} // WebFetch method

function WebListDownload(lUrls, sFolder, bUnique) {
// Download a list of URLs, specifying folder and whether to ensure unique file names

for (var i = 0; i < lUrls.Count; i++) {
var sUrl = lUrls(i)
var sFile = WebUrlDownloadPath(sUrl, sFolder, bUnique)
WebUrlToFile(sUrl, sFile)
}
} // WebListDonload method

function WebRequest(sType, sUrl, dData, dHeaders, sUser, sPassword) {
// Send a web request and return the response

var sType = sType.toUpperCase()
var sData = null
if (JsIsObject(dData)) {
var d = VtDictionaryToJs(dData)
sData = JsDictionaryToEncodedString(d)
}

if (sType == 'GET' && sData) sUrl += '?' + sData

if (sType == 'POST') var oRequest = VtCreateWebRequest()
// if (1) var oRequest = VtCreateWebRequest()
else var oRequest = VtCreateWinHttpRequest()

try {
oRequest.open(sType, sUrl, false, sUser, sPassword)
}
catch (e) {
return null
}
oRequest.setRequestHeader('User-Agent', 'Homer')
if (sType == 'POST') oRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')

// if (JsIsObject(dHeaders)) {
if (dHeaders) {
var d = VtDictionaryToJs(dHeaders)
for (var sKey in d) {
var sValue = d[sKey]
oRequest.setRequestHeader(sKey, sValue)
}
}

try {
if (sType == 'POST') {
oRequest.send(sData)
}
else oRequest.send()
}
catch (e) {
// DialogShow('Error', e.description)
}
return oRequest
} // WebRequest method

function WebRequestAllHeaders(sUrl) {
// Get all response headers

var dData = null
var dHeaders = null
var sUser = null
var sPassword = null

var oRequest = WebRequestHead(sUrl, dData, dHeaders, sUser, sPassword)
var sReturn = xMute
try {sReturn = oRequest.getAllResponseHeaders()}
catch (e) {}

oRequest = null
return sReturn
} // WebRequestAllHeaders method


function WebRequestGet(sUrl, dData, dHeaders, sUser, sPassword) {
// Send a get request

return WebRequest('GET', sUrl, dData, dHeaders, sUser, sPassword)
} // WebRequestGet method

function WebRequestGetToFile(sUrl, dData, dHeaders, sUser, sPassword, sFile) {
// Send a get request and save response to file

return WebRequestToFile('GET', sUrl, dData, dHeaders, sUser, sPassword, sFile)
} // WebRequestGetToFile method

function WebRequestGetToString(sUrl, dData, dHeaders, sUser, sPassword) {
// Send a get request and return response as string

return WebRequestToString('GET', sUrl, dData, dHeaders, sUser, sPassword)
} // WebRequestGetToString method

function WebRequestHead(sUrl, dData, dHeaders, sUser, sPassword) {
// Send a head request

return WebRequest('HEAD', sUrl, dData, dHeaders, sUser, sPassword)
} // WebRequestHead method

function WebRequestHeader(sUrl, sHeader) {
// Get response header

var dData = null
var dHeaders = null
var sUser = null
var sPassword = null

var oRequest = WebRequestHead(sUrl, dData, dHeaders, sUser, sPassword)
var sReturn = xMute
try {sReturn = oRequest.getResponseHeader(sHeader)}
catch (e) {}

oRequest = null
return sReturn
} // WebRequestHeader method

function WebRequestPost(sUrl, dData, dHeaders, sUser, sPassword) {
// Send a post request

return WebRequest('POST', sUrl, dData, dHeaders, sUser, sPassword)
} // WebRequestPost method

function WebRequestPostToFile(sUrl, dData, dHeaders, sUser, sPassword, sFile) {
// Send a post request and save response to file

return WebRequestToFile('POST', sUrl, dData, dHeaders, sUser, sPassword, sFile)
} // WebRequestPostToFile method

function WebRequestPostToString(sUrl, dData, dHeaders, sUser, sPassword) {
// Send a post request and return response as string

if (!sUser) sUser = null
return WebRequestToString('POST', sUrl, dData, dHeaders, sUser, sPassword)
} // WebRequestPostToString method

function WebRequestToFile(sType, sUrl, dData, dHeaders, sUser, sPassword, sFile) {
// Save web resource to file

var oRequest = WebRequest(sType, sUrl, dData, dHeaders, sUser, sPassword)
var aBytes = oRequest.responseBody
var bReturn = VtStreamToFile(aBytes, sFile)
oRequest = null
return bReturn
} // WebRequestToFile method

function WebRequestToString(sType, sUrl, dData, dHeaders, sUser, sPassword) {
// Return web resource as string

var oRequest = WebRequest(sType, sUrl, dData, dHeaders, sUser, sPassword)
var sReturn = xMute
try {
sReturn = oRequest.responseText
}
catch (e) {
var aBytes = oRequest.responseBody
// var sReturn = VtArrayToString(aBytes)
var sFile = PathGetTempFile()
var bResult = VtStreamToFile(aBytes, sFile)
sReturn = FileToString(sFile)
FileDelete(sFile)
}
oRequest = null
return sReturn
} // WebRequestToString method

function WebUrlContentDisposition(sUrl){
// Get suggested file name of a web resource

var sHeader = 'content-disposition'
var sReturn = WebRequestHeader(sUrl, sHeader)
var aParts = sReturn.split('=')
var iLength = aParts.length
sReturn = aParts[iLength - 1]
sReturn = VtTrim(sReturn)
return sReturn
} // WebUrlContentDisposition method


function WebUrlContentEncoding(sUrl){
// Get encoding of a web resource

var sHeader = 'Content-Encoding'
var sReturn = WebRequestHeader(sUrl, sHeader)
return sReturn
} // WebUrlContentEncoding method

function WebUrlContentLanguage(sUrl){
// Get natural language code of a web resource

var sHeader = 'Content-Language'
var sReturn = WebRequestHeader(sUrl, sHeader)
return sReturn
} // WebUrlContentLanguage method

function WebUrlContentLength(sUrl){
// Get content length of a web resource

var sHeader = 'content-length'
var sReturn = WebRequestHeader(sUrl, sHeader)
return sReturn
} // WebUrlContentLength method

function WebUrlContentLocation(sUrl){
// Get redirected location of a web resource

var sHeader = 'Content-Location'
var sReturn = WebRequestHeader(sUrl, sHeader)
return sReturn
} // WebUrlContentLocation method

function WebUrlContentType(sUrl){
// Get content type of a web resource

var sHeader = 'content-type'
var sReturn = WebRequestHeader(sUrl, sHeader)
return sReturn
} // WebUrlContentType method

function WebUrlDownloadFileName(sUrl) {
// Get or generate download file name from URL, trying various techniques

var sFile = xMute
var sBase = xMute
var sExtension = xMute

var sUrl = UrlNormalize(sUrl, null)
var sQuery = UrlGetQuery(sUrl)
if (!sQuery) sFile = UrlGetFileName(sUrl)

if (!sFile) sFile = WebUrlContentDisposition(sUrl)

if (!sFile) {
var sRedirectUrl = WebUrlRedirect(sUrl)
if (sRedirectUrl) sFile = UrlGetFileName(sRedirectUrl)
}

if (sFile) {
sBase = PathGetBase(sFile)
sExtension = PathGetExtension(sFile)
}

if (!sBase) {
var sPathPlus = UrlGetPathPlus(sUrl)
if (sPathPlus) sBase = sPathPlus
}

if (!sExtension) {
if (WebUrlIsHtml(sUrl)) {
sExtension = 'htm'
if (!sBase) sBase = 'page'
}
else {
var sType = WebUrlContentType(sUrl)
var aParts = sType.split('/')
var iLength = aParts.length
if (iLength && aParts[0]) sExtension = aParts[iLength - 1]
}
}

if (!sBase) sBase = 'file'
if (!sExtension) sExtension = 'bin'
var sReturn = sBase + '.' + sExtension
return sReturn
} // WebUrlDownloadFileName method


function WebUrlDownloadPath(sUrl, sFolder, bUnique) {
// Obtain download path for a web resource

var sName = WebUrlDownloadFileName(sUrl)
var sBase = PathGetBase(sName)
var sExtension = PathGetExtension(sName)
var sReturn = PathGetValid(sFolder, sBase, sExtension, bUnique)
return sReturn
} // WebDownloadPath method

function WebUrlIsHtml(sUrl) {
// Test whether content type is text/html

var sType = WebUrlContentType(sUrl)
return StringStartsWith(sType, 'text/html', true)
} // WebUrlIsHtml method

function WebUrlLastModified(sUrl){
// Get last modification time stamp of a web resource

var sHeader = 'LastModified'
var sReturn = WebRequestHeader(sUrl, sHeader)
return sReturn
} // WebUrlLastModified method

function WebUrlRedirect(sUrl){
// Get url after redirects

var dData = null
var dHeaders = null
var sUser = null
var sPassword = null

var oRequest = WebRequestHead(sUrl, dData, dHeaders, sUser, sPassword)
var sReturn = xMute
try {sReturn = oRequest.Option(1)}
catch (e) {}

oRequest = null
return sReturn
} // WebUrlRedirect method

function WebUrlServer(sUrl){
// Get server name and version

var sHeader = 'Server'
var sReturn = WebRequestHeader(sUrl, sHeader)
return sReturn
} // WebUrlServer method

function WebUrlToFile(sUrl, sFile) {
// Save web resource to file

var dData = null
var dHeaders = null
var sUser = null
var sPassword = null

return WebRequestGetToFile(sUrl, dData, dHeaders, sUser, sPassword, sFile)
} // WebUrlToFile method

function WebUrlToString(sUrl) {
// Return web resource as string

var dData = null
var dHeaders = null
var sUser = null
var sPassword = null

return WebRequestGetToString(sUrl, dData, dHeaders, sUser, sPassword)
} // WebUrlToString method

function WebUrlToXml(sUrl) {
// Return web resource as XML document

var dData = null
var dHeaders = null
var sUser = null
var sPassword = null

var sText = WebUrlToString(sUrl)
var oDoc = VtCreateXmlDocument()
oDoc.loadXML(sText)
return oDoc
} // WebUrlToXml method

function XmlAppendElement(oParent, sName, sValue) {
// Append element to a node

var oChild = XmlCreateElement(oParent, sName, sValue)
oParent.appendChild(oChild)
return oChild
} // XmlAppendElement method

function XmlCreateElement(oNode, sName, sValue) {
// Create an XML element

var oChild = null
if (JsIsUndefined(sValue)) sValue = null
if (JsIsObject(oNode)) {
var oDoc
if (VtTypeName(oNode) == 'DOMDocument') oDoc = oNode
else oDoc = oNode.ownerDocument

var oChild = oDoc.createElement(sName)
if (!JsIsNull(sValue)) {
var oData = oDoc.createCDATASection(sValue)
oChild.appendChild(oData)
}
}

oDoc = null
return oChild
} // XmlCreateElement method

function XmlCreateFile(sFile) {
// Create a root XML file

var oDoc = VtCreateXmlDocument()
XmlAppendElement(oDoc, 'Root', null)
FileDelete(sFile)
oDoc.save(sFile)
return oDoc
} // XmlCreateFile method

function XmlEnsureGetNode(sFile, sPath) {
// Return a node, creating preceding elements if necessary

var oNode = null
var oDoc
if (JsIsObject(sFile)) oDoc = sFile
else oDoc = XmlEnsureOpenFile(sFile)

if (JsIsObject(oDoc)) {
var oParent
if (VtTypeName(oDoc) == 'DOMDocument') oParent = oDoc.documentElement
else oParent = oDoc

var oNode
if (!sPath.length) oNode = oParent
else {
oNode = XmlGetNode(oParent, sPath)
if (JsIsNull(oNode)) {
var aNames = sPath.split('/')
var sName = aNames.pop()
var sPath = aNames.join('/')
oParent = XmlEnsureGetNode(oDoc, sPath)
oNode = XmlAppendElement(oParent, sName, null)
}
}
}

oParent = null
oDoc = null
return oNode
} // XmlEnsureGetNode method

function XmlEnsureOpenFile(sFile) {
// Open an XML file, creating it if necessary

var oDoc = XmlOpenFile(sFile)
if (JsIsNull(oDoc)) oDoc = XmlCreateFile(sFile)
return oDoc
} // XmlEnsureOpenFile method

function XmlGetAttribute(sFile, sPath, sAttribute, sDefault) {
// Get an attribute of a node

var sReturn = sDefault
if (JsIsUndefined(sReturn)) sReturn = null
var oDoc
if (JsIsObject(sFile)) oDoc = sFile
else oDoc = XmlOpenFile(sFile)

if (JsIsObject(oDoc)) {
var oParent
if (VtTypeName(oDoc) == 'DOMDocument') oParent = oDoc.documentElement
else oParent = oDoc

var oNode = oParent.selectSingleNode(sPath)
if (JsIsObject(oNode)) {
var sText = oNode.getAttribute(sAttribute)
if (sText != null) sReturn = sText
}
}

oNode = null
oParent = null
oDoc = null
return sReturn
} // XmlGetAttribute method

function XmlGetNode(sFile, sPath) {
// Get a node

var oNode = null
var oDoc
if (JsIsObject(sFile)) oDoc = sFile
else oDoc = XmlOpenFile(sFile)

if (JsIsObject(oDoc)) {
var oParent
if (VtTypeName(oDoc) == 'DOMDocument') oParent = oDoc.documentElement
else oParent = oDoc

var oNode = oParent.selectSingleNode(sPath)
}

oParent = null
oDoc = null
return oNode
} // XmlGetNode method

function XmlGetNodeNames(sFile, sPath) {
// Get node names

var lReturn = VtCreateList()
var oDoc
if (JsIsObject(sFile)) oDoc = sFile
else oDoc = XmlOpenFile(sFile)

if (JsIsObject(oDoc)) {
var oParent
if (VtTypeName(oDoc) == 'DOMDocument') oParent = oDoc.documentElement
else oParent = oDoc

var oNodes = oParent.selectNodes(sPath)
for (var i = 0; i < oNodes.length; i++) {
var oNode = oNodes.item(i)
lReturn.Add(oNode.nodeName)
}
}

oNode = null
oNodes = null
oParent = null
oDoc = null
return lReturn
} // XmlGetNodeNames method

function XmlGetNodes(sFile, sPath) {
// Get a node list

var lReturn = VtCreateList()
var oDoc
if (JsIsObject(sFile)) oDoc = sFile
else oDoc = XmlOpenFile(sFile)

if (JsIsObject(oDoc)) {
var oParent
if (VtTypeName(oDoc) == 'DOMDocument') oParent = oDoc.documentElement
else oParent = oDoc

var oNodes = oParent.selectNodes(sPath)
for (var i = 0; i < oNodes.length; i++) {
var oNode = oNodes.item(i)
lReturn.Add(oNode)
}
}

// oNode = null
// oNodes = null
// oParent = null
// oDoc = null
return lReturn
} // XmlGetNodes method

function XmlGetText(sFile, sPath, sDefault) {
// Get the text of a node

var sReturn = sDefault
if (JsIsUndefined(sReturn)) sReturn = null
var oDoc
if (JsIsObject(sFile)) oDoc = sFile
else oDoc = XmlOpenFile(sFile)

if (JsIsObject(oDoc)) {
var oParent
if (VtTypeName(oDoc) == 'DOMDocument') oParent = oDoc.documentElement
else oParent = oDoc

var oNode = oParent.selectSingleNode(sPath)
if (JsIsObject(oNode)) {
var sText = oNode.text
if (sText != null) sReturn = sText
}
}

oNode = null
oParent = null
oDoc = null
return sReturn
} // XmlGetText method

function XmlGetValue(sFile, sPath, sDefault) {
// Get the value of a node

var sReturn = sDefault
if (JsIsUndefined(sReturn)) sReturn = null
var oDoc
if (JsIsObject(sFile)) oDoc = sFile
else oDoc = XmlOpenFile(sFile)

if (JsIsObject(oDoc)) {
var oParent
if (VtTypeName(oDoc) == 'DOMDocument') oParent = oDoc.documentElement
else oParent = oDoc

var oNode = oParent.selectSingleNode(sPath)
if (JsIsObject(oNode)) {
var sValue = oNode.nodeValue
if (sValue != null) sReturn = sValue
}
}

oNode = null
oParent = null
oDoc = null
return sReturn
} // XmlGetValue method

function XmlOpenFile(sFile) {
// Open an XML file

if (!FileExists(sFile)) return null

var oDoc = VtCreateXmlDocument()
try {
oDoc.load(sFile)
}
catch (e) {
oDoc = null
}
return oDoc
} // XmlOpenFile method

function XmlRemoveAttribute(sFile, sPath, sAttribute) {
// Remove an attribute

var oDoc
if (JsIsObject(sFile)) oDoc = sFile
else oDoc = XmlOpenFile(sFile)

if (JsIsObject(oDoc)) {
var oParent
if (VtTypeName(oDoc) == 'DOMDocument') oParent = oDoc.documentElement
else oParent = oDoc

var oNode = oParent.selectSingleNode(sPath)
if (JsIsObject(oNode)) {
oNode.removeAttribute(sAttribute)
oDoc.save(sFile)
}
}

oNode = null
oParent = null
oDoc = null
} // XmlRemoveAttribute method

function XmlRemoveNode(sFile, sPath) {
// Remove a node

var oDoc
if (JsIsObject(sFile)) oDoc = sFile
else oDoc = XmlOpenFile(sFile)

if (JsIsObject(oDoc)) {
var oParent
if (VtTypeName(oDoc) == 'DOMDocument') oParent = oDoc.documentElement
else oParent = oDoc

var oNode = oParent.selectSingleNode(sPath)
if (JsIsObject(oNode)) {
oParent = oNode.parentNode
oParent.removeChild(oNode)
oDoc.save(sFile)
}
}

oNode = null
oParent = null
oDoc = null
} // XmlRemoveNode method

function XmlRemoveNodes(sFile, sPath) {
// Remove a node collection

var oDoc
if (JsIsObject(sFile)) oDoc = sFile
else oDoc = XmlOpenFile(sFile)

if (JsIsObject(oDoc)) {
var oParent
if (VtTypeName(oDoc) == 'DOMDocument') oParent = oDoc.documentElement
else oParent = oDoc

var oNodes = oParent.selectNodes(sPath)
if (oNodes.length) {
var oParent = oNodes.firstChild.parentNode
for (var i = oNodes.length - 1; i >= 0; i--) {
var oNode = oNodes.item(i)
oParent.removeChild(oNode)
}
oDoc.save(sFile)
}
}

oNode = null
oNodes = null
oParent = null
oDoc = null
} // XmlRemoveNodes method

function XmlSetAttribute(sFile, sPath, sAttribute, sText) {
// Set an attribute

var oNode = XmlEnsureGetNode(sFile, sPath)
if (JsIsObject(oNode)) {
oNode.setAttribute(sAttribute, sText)
var oDoc
if (VtTypeName(oNode) == 'DOMDocument') oDoc = oNode
else oDoc = oNode.ownerDocument
if (!JsIsObject(sFile)) oDoc.save(sFile)
}

oNode = null
oDoc = null
return (XmlGetAttribute(sFile, sPath, sAttribute, null) == sText)
} // XmlSetAttribute method

function XmlSetText(sFile, sPath, sText) {
// Set text of an element

return XmlSetValue(sFile, sPath, sText)
} // XmlSetText method

function XmlSetValue(sFile, sPath, sValue) {
// Set a value

var oNode = XmlEnsureGetNode(sFile, sPath)
if (JsIsObject(oNode)) {
var aNames = sPath.split('/')
var sName = aNames.pop()

var oDoc
if (VtTypeName(oNode) == 'DOMDocument') oDoc = oNode
else oDoc = oNode.ownerDocument
var oNew = XmlCreateElement(oDoc, sName, sValue)
var oAttributes = oNode.attributes
for (var i = 0; i < oAttributes.length; i++) {
var oAttribute = oAttributes.item(i)
var sAttribute = oAttribute.nodeName
var sText = oNode.getAttribute(sAttribute)
oNew.setAttribute(sAttribute, sText)
}
var oParent = oNode.parentNode
oParent.replaceChild(oNew, oNode)
if (!JsIsObject(sFile)) oDoc.save(sFile)
}

oNew = null
oNode = null
oDoc = null
return (XmlGetValue(sFile, sPath, null) == sValue)
} // XmlSetValue method

function XmlToVtDictionary(sFile) {
// Convert XML file to variant dictionary

var dReturn = VtCreateDictionary()
var oNodes = XmlGetNodes(sFile, '*')
for (var i = 0; i < oNodes.length; i++) {
var oNode = oNodes.item(i)
var sName = oNode.nodeName
var sValue = oNode.text
dReturn(sName) = sValue
}
return dReturn
} // XmlToVtDictionary method
]]>
</script>
</component>
